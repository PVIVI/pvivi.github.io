<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
  <title>Linux Command | pan D.wei&#39;s Blog</title>
  <meta name="description" content="" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="MobileOptimized" content="320" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" type="text/css" href="/css/component.css" />
  <link rel="stylesheet" type="text/css" href="/css/screen.css" />
  <meta name="generator" content="pan D.wei's Blog">
  <script src="http://static.duoshuo.com/embed.js"></script>
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("WlEt6BpzYCC3DYc6BA8Gm34p-gzGzoHsz", "j8XNnOegrpFwzRM8seXAekgf");</script>

  
  
  

  
  
</head>
<body>
<div class="container">
    <div class="mp-pusher" id="mp-pusher">
        <i id="scroll-up" class="fa fa-angle-up"></i>
        <nav id="mp-menu" class="mp-menu">
            <div class="mp-level">
                <a data-pjax class="back-home" style="font-size: 20px" href="/"><h2 ><i class="fa fa-home"></i>
                        Home</h2></a>
                <ul class="first-level">
                    <li>
                        <a class="fa fa-archive" href="#"><i class="fa fa-angle-left">
                            </i>&nbsp;&nbsp;Archive</a>
                        <div class="mp-level page-list">
                            <h2 ><i class="fa fa-archive"></i>
                                Archive</h2>
                            <a class="mp-back" href="#">back</a>
                            <form id="search-form" action="">
                                <input type="text" class="search search-archive" placeholder="Search.."/>
                            </form>
                            <ul>
                                <div class="mp-scroll">
                                
                                <li class="search-archive-li">
                                    <a href="/2018/04/07/用redis构建分布式锁/">用redis构建分布式锁</a>
                                </li>
                                
                                <li class="search-archive-li">
                                    <a href="/2018/03/16/虚拟内存/">虚拟内存</a>
                                </li>
                                
                                <li class="search-archive-li">
                                    <a href="/2017/12/27/API限流策略与Tocken-Bucket算法实现/">API限流策略与Tocken Bucket算法实现</a>
                                </li>
                                
                                <li class="search-archive-li">
                                    <a href="/2017/11/25/使用nginx分流进行A-B测试/">使用nginx分流进行A/B测试</a>
                                </li>
                                
                                <li class="search-archive-li">
                                    <a href="/2017/06/20/Median-of-Two-Sorted-Arrays/">Median of Two Sorted Arrays</a>
                                </li>
                                
                                <li class="search-archive-li">
                                    <a href="/2016/03/31/Linux-Command/">Linux Command</a>
                                </li>
                                
                                </div>
                            </ul>
                        </div>
                    </li>
                    <li>
                        <a class="fa fa-copy" href="#"><i class="fa fa-angle-left">
                            </i>&nbsp;&nbsp;Categories</a>

                        <div class="mp-level page-list">
                            <h2 ><i class="fa fa-copy"></i>
                                Categories</h2>
                            <a class="mp-back" href="#">back</a>
                            <form id="search-form" action="">
                                <input type="text" class="search search-category" placeholder="Search.."/>
                            </form>
                            <ul>
                                <div class="mp-scroll">
                                
                                <li class="search-category-li">
                                    <a href="/categories/learning/">&nbsp;&nbsp;&nbsp;learning</a>
                                    <small>5</small>
                                </li>
                                
                                </div>
                            </ul>
                        </div>
                    </li>
                    <li>
                        <a class="fa fa-tags" href="#"><i class="fa fa-angle-left">
                            </i>&nbsp;&nbsp;Tags</a>
                        <div class="mp-level page-list">
                            <h2 ><i class="fa fa-tags"></i>
                                Tags</h2>
                            <a class="mp-back" href="#">back</a>
                            <form id="search-form" action="">
                                <input type="text" class="search search-tag" placeholder="Search.."/>
                            </form>
                            <ul>
                                <div class="mp-scroll">
                                
                                <li class="search-tag-li">
                                    <a href="/tags/OS/">&nbsp;&nbsp;&nbsp;OS</a>
                                    <small>1</small>
                                </li>
                                
                                <li class="search-tag-li">
                                    <a href="/tags/algorithm/">&nbsp;&nbsp;&nbsp;algorithm</a>
                                    <small>3</small>
                                </li>
                                
                                <li class="search-tag-li">
                                    <a href="/tags/cache/">&nbsp;&nbsp;&nbsp;cache</a>
                                    <small>2</small>
                                </li>
                                
                                <li class="search-tag-li">
                                    <a href="/tags/linux/">&nbsp;&nbsp;&nbsp;linux</a>
                                    <small>4</small>
                                </li>
                                
                                </div>
                            </ul>
                        </div>
                    </li>
                    
                    <li><a class="fa fa-user" href="/about">&nbsp;&nbsp;&nbsp;About me</a></li>

                </ul>

            </div>
        </nav>
        <div id="pjax">
            <div class="pjax-hidden" style="display: none">
                
                    <a  data-pjax href="/2018/04/07/用redis构建分布式锁/">用redis构建分布式锁</a>
                
                    <a  data-pjax href="/2018/03/16/虚拟内存/">虚拟内存</a>
                
                    <a  data-pjax href="/2017/12/27/API限流策略与Tocken-Bucket算法实现/">API限流策略与Tocken Bucket算法实现</a>
                
                    <a  data-pjax href="/2017/11/25/使用nginx分流进行A-B测试/">使用nginx分流进行A/B测试</a>
                
                    <a  data-pjax href="/2017/06/20/Median-of-Two-Sorted-Arrays/">Median of Two Sorted Arrays</a>
                
                    <a  data-pjax href="/2016/03/31/Linux-Command/">Linux Command</a>
                
                
                    <a data-pjax href="/categories/learning/">&nbsp;&nbsp;learning</a>
                
                
                    <a data-pjax href="/tags/OS/">&nbsp;&nbsp;OS</a>
                
                    <a data-pjax href="/tags/algorithm/">&nbsp;&nbsp;algorithm</a>
                
                    <a data-pjax href="/tags/cache/">&nbsp;&nbsp;cache</a>
                
                    <a data-pjax href="/tags/linux/">&nbsp;&nbsp;linux</a>
                
                <a data-pjax class="fa fa-user" href="/about">&nbsp;&nbsp;&nbsp;About me</a>
            </div>
            <nav class="nexus">
                <li  style="border-left: 1px solid #c6d0da;">
                    <a id="trigger" href="#"><i class="fa fa-bars"></i></a>
                </li>
                <li ><a id="nexus-back" data-pjax href="/">pan D.wei&#39;s Blog</a></li>
                
                <div id="nav-container">
                    <div class="post-navbar" style="line-height: 63px;display:none">
                        <li id="navbar-title"><a href="#">Linux Command</a></li>
                        <li id="navbar-toc" style="border-left: none">
                            <a style="padding-right: 15px">
                                <span id="toc-content" >Introduction</span><i class="fa fa-chevron-down" ></i>
                            </a>
                            <div class="hidden-box">
                                <ul id="toc"></ul>
                            </div>
                        </li>
                    </div>
                </div>
                
            </nav>

            <div class="scroller">
            <div class="scroller-inner">

<!-- -->
<!--<body class="post-template">-->
<!---->
  
<main class="content" role="main">
    <article class="post" >
    <span class="post-meta">
                  <div class="tag-tile">
                      
                      
                      <a data-pjax href='/tags/linux/' style='color:#D5D5D5'>linux</a>
                      
                      
                  </div>
                <h1 class="post-title" style="margin: 14px 0;color:#50585D">Linux Command</h1>

                    <div class="post-meta">
                        Post on<span class="fa fa-clock-o"></span>
                        <time datetime="2016-03-31T04:04:47.000Z"
                              itemprop="datePublished">2016-03-31</time>
                        
                        <span class="post-meta-divider">|</span>     
                        Views<span class="fa fa-eye"></span>
                        <x class="leancloud-visitors-count"></x>
                    </div>     
    </span>
        <section id="/2016/03/31/Linux-Command/" class="post-content">
            <h2 id="1-获取字符串长度"><a href="#1-获取字符串长度" class="headerlink" title="1. 获取字符串长度"></a>1. 获取字符串长度</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var=123456</span><br><span class="line">length=$&#123;#var&#125;</span><br></pre></td></tr></table></figure>
<hr>
<a id="more"></a>
<h2 id="2-算数运算"><a href="#2-算数运算" class="headerlink" title="2. 算数运算"></a>2. 算数运算</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a=123</span><br><span class="line">b=4456</span><br><span class="line">let res=a+b</span><br><span class="line">let res=a-b</span><br><span class="line">let res--</span><br><span class="line">let res++</span><br><span class="line">let res+=6</span><br><span class="line">let res-=6</span><br><span class="line">res=$[a+b]</span><br><span class="line">res=$[$res+a]</span><br><span class="line">res=$((a+b))</span><br></pre></td></tr></table></figure>
<p>以上只能进行<code>整数运算</code>，使用<code>bc</code>可以进行<code>浮点运算</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">echo "4 * 0.56" | bc</span><br><span class="line">res=$(echo "$a * 1.234"|bc)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> scale可以控制精度，用分号隔开</span><br><span class="line">echo "scale=2;3/8" | bc</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 进制转换</span><br><span class="line">no=100</span><br><span class="line">echo "obase=2;$no" | bc</span><br><span class="line">no=1100100</span><br><span class="line">echo "obase=10;ibase=2;$no" | bc</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 计算平方和平方根</span><br><span class="line">echo "sqrt(100)" | bc</span><br><span class="line">echo "10^10" | bc</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="3-创建文件描述符"><a href="#3-创建文件描述符" class="headerlink" title="3. 创建文件描述符"></a>3. 创建文件描述符</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 使用文件描述符3打开并读取文件</span><br><span class="line"><span class="meta">#</span> 文件描述符只能用一次，读取完还想再读需要在创建一次</span><br><span class="line">exec 3 &lt; input.txt</span><br><span class="line">cat &lt;&amp;3</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 创建一个文件描述符用于写入（截断）</span><br><span class="line">exec 4&gt;output.txt</span><br><span class="line">echo haha &gt;&amp;4</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 创建一个文件描述符用于写入（追加）</span><br><span class="line">exec 5&gt;&gt;input.txt</span><br><span class="line">echo append line &gt;&amp;5</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="4-数组和关联数组"><a href="#4-数组和关联数组" class="headerlink" title="4. 数组和关联数组"></a>4. 数组和关联数组</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">array=(1 2 3 4 5)</span><br><span class="line">echo $&#123;array[3]&#125;</span><br><span class="line">index=1</span><br><span class="line"><span class="meta">array[$</span>index]="test1"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 打印数组</span><br><span class="line">echo $&#123;array[@]&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 打印数组长度</span><br><span class="line">echo $&#123;#array[*]&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> bash 4.0引入关联数组</span><br><span class="line"><span class="meta">#</span> 申明一个关联数组</span><br><span class="line">declare -A ass_array</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 提供索引-值列表来初始化</span><br><span class="line">ass_array=([index1]=val1 [index2]=val2)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 使用独立的索引-值进行赋值</span><br><span class="line">ass_array[index3]=val3</span><br><span class="line">ass_array[index4]=val4</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 获取索引</span><br><span class="line">echo $&#123;!ass_array[@]&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 获取值</span><br><span class="line">echo $&#123;ass_array[@]&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="5-重命名"><a href="#5-重命名" class="headerlink" title="5. 重命名"></a>5. 重命名</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">alias new_command='command sequence'</span><br><span class="line">alias install='sudo apt-get install'</span><br><span class="line"><span class="meta">#</span> alias只是暂时的，可以将alias写入~/.bashrc。</span><br><span class="line"><span class="meta">#</span> 当一个新的shell进程生成时，都会去执行.bashrc文件</span><br><span class="line"><span class="meta">#</span> 使用别名有安全问题，攻击者可能用一些恶意命令取代较为常用的命令。</span><br><span class="line"><span class="meta">#</span> 在命令前面加上\可以使用命令的原始形式，忽略可能存在的别名设置</span><br><span class="line">\command</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="6-日期设置"><a href="#6-日期设置" class="headerlink" title="6. 日期设置"></a>6. 日期设置</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 读取日期</span><br><span class="line">date</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Unix时间：1970.1.1 0：0：0至今的秒数</span><br><span class="line">date +%s</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 提供一个日期，以任意格式输出。如下获取星期</span><br><span class="line">date --date "Apr 27 2016" +%A</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 按照需要的格式打印出日期</span><br><span class="line">date "+%d %B %Y"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 设置日期和时间</span><br><span class="line"><span class="meta">#</span> date -s "21 June 2009 11:00:00"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 计时</span><br><span class="line">start=$(date +%s)</span><br><span class="line">commands</span><br><span class="line">end=$(date +%s)</span><br><span class="line">difference=$(( end-start ))</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="7-函数"><a href="#7-函数" class="headerlink" title="7. 函数"></a>7. 函数</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 函数可加function，也可不加</span><br><span class="line">function func()&#123;</span><br><span class="line">  echo $0;     # 脚步名字</span><br><span class="line">  echo $1,$2;  # 访问参数1，参数2</span><br><span class="line">  echo "$@";   # 扩展为“$1”，“$2”，“$3”</span><br><span class="line">  echo $*;     # 扩展为$1c$2c$3..其中c是IFS的第一个字符</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hello()&#123;</span><br><span class="line">  echo hello</span><br><span class="line">  return 123</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 使用export导出函数，其作用域扩展到子进程</span><br><span class="line">export -f hello</span><br><span class="line"><span class="meta">#</span> 执行函数</span><br><span class="line">func param1 param2 # 传递参数</span><br><span class="line">hello</span><br><span class="line">echo $? # 获取到hello的返回值</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="8-获取管道命令输出"><a href="#8-获取管道命令输出" class="headerlink" title="8. 获取管道命令输出"></a>8. 获取管道命令输出</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"><span class="meta">#</span> 读取命令序列的输出</span><br><span class="line"><span class="meta">#</span> 子shell方式，子shell就是一个子进程</span><br><span class="line"><span class="meta">#</span> 在命令外面加上双引号，可以保留换行符。</span><br><span class="line">output="$(ls /root |cat -n)"</span><br><span class="line">echo 'output:' $output</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 反引用。在键盘~按键上</span><br><span class="line">output2=`ls /root |cat -n`</span><br><span class="line">echo 'output2:' $output2</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="9-分割字符串"><a href="#9-分割字符串" class="headerlink" title="9. 分割字符串"></a>9. 分割字符串</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"><span class="meta">#</span> 分割字符串</span><br><span class="line">data="name,sex,rollno,location"</span><br><span class="line">oldIFS=$IFS</span><br><span class="line">echo "oldIFS:" $oldIFS</span><br><span class="line">IFS=，</span><br><span class="line">for item in $data;do</span><br><span class="line">echo $item</span><br><span class="line">done</span><br><span class="line">IFS=$oldIFS</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="10-循环"><a href="#10-循环" class="headerlink" title="10. 循环"></a>10. 循环</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">array=(1 2 3 4 5)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> for循环</span><br><span class="line">echo -n "for:"</span><br><span class="line">for var in $&#123;array[@]&#125;;do</span><br><span class="line">echo -n $var ' '</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> while循环</span><br><span class="line">echo</span><br><span class="line">echo -n 'while:'</span><br><span class="line">len=$&#123;#array[@]&#125;</span><br><span class="line">while (( len &gt;= 0 ));do</span><br><span class="line">echo -n $&#123;array[len]&#125; ' '</span><br><span class="line">let len--</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> until循环</span><br><span class="line">echo</span><br><span class="line">echo -n 'until:'</span><br><span class="line">len=$&#123;#array[@]&#125;</span><br><span class="line"><span class="meta">#</span> 在条件为真之前，until会一直执行</span><br><span class="line">until (( len&lt;0 ));do</span><br><span class="line">echo -n $&#123;array[len]&#125; ' '</span><br><span class="line">let len--</span><br><span class="line">done</span><br><span class="line">echo</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="11-条件判断"><a href="#11-条件判断" class="headerlink" title="11. 条件判断"></a>11. 条件判断</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line">x=0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 使用两个方括号内部可以使用比较符号</span><br><span class="line">if [[ $x &gt; 100 ]];then</span><br><span class="line">echo "x&gt;100"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 只有一个方括号，只能使用命令进行比较，比如：gt,lt,ge,le</span><br><span class="line">elif [ $x -gt 10 ];then</span><br><span class="line">echo "x&gt;10"</span><br><span class="line">else</span><br><span class="line">echo "other"</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 简化写法,这时候只能用一个方括号的形式</span><br><span class="line">[ $x -ge 0 ] &amp;&amp; echo "x&gt;=0"</span><br><span class="line">[ $x -lt 0 ] || echo "x&gt;=0" # 为假时执行</span><br><span class="line">str1=abcdef</span><br><span class="line">str2=abcdef</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 字符串比较最好用双括号形式，单括号有时会错.</span><br><span class="line"><span class="meta">#</span> 里面可以用一个或两个等号，而且前后都必须要有空格，否则就变成赋值了。</span><br><span class="line"><span class="meta">#</span> 在if中可以用&amp;&amp;和||来连接逻辑判断</span><br><span class="line">if [[ $str1 == $str2 ]];then</span><br><span class="line">echo 'str1!=str2'</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<ul>
<li>[ -f $file_var ] : 文件判断</li>
<li>[ -x $var ] : 可执行文件判断</li>
<li>[ -d $var ] : 目录判断</li>
<li>[ -e $var ] : 文件存在判断</li>
<li>[ -c $var ] : 字符设备文件判断</li>
<li>[ -b $var ] : 块设备文件判断</li>
<li>[ -w $var ] : 文件可写判断</li>
<li>[-r $var ] : 文件可读判断</li>
<li>[ -L $var ] : 符号链接判断</li>
</ul>
<hr>
<h2 id="12-find"><a href="#12-find" class="headerlink" title="12. find"></a>12. find</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> -iname忽略大小写的匹配</span><br><span class="line">find -iname "example*" -print</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> -o选项，是或的意思，满足一个条件即可。括号前后要空格</span><br><span class="line">find /root \( -name "*.txt" -o -name "*.pdf" \) -print</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> path将文件路径作为整体进行匹配</span><br><span class="line">find /root/ -path "*shell*" -print</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 不匹配txt和sh结尾的</span><br><span class="line">find /root/shell_test ! \( -name "*txt" -o -name "*sh" \) -print</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 定义查找的最大深度为3，从深度2开始查找。</span><br><span class="line"><span class="meta">#</span> mindepth和maxdepth应该放在其他选项前面，这样可以提高效率</span><br><span class="line"><span class="meta">#</span> type指定查找的文件类型，d:目录，f：文件，l：符号链接.除此之外还有其他文件类型</span><br><span class="line">find /root -mindepth 2 -maxdepth 3 -type d -print</span><br><span class="line">echo newer:</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 找出比test.txt新的文件</span><br><span class="line">find /root -type f -newer ./test.txt -print</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 找出大于2KB的文件,小于2k用 -2k，大于等于用 2k。</span><br><span class="line">find . -type f -size +2k</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 删除匹配文件。删除所有swp文件</span><br><span class="line">find . -type f -name "*.swp" -delete</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 根据文件权限进行查找。找出没有apache执行权限的php文件</span><br><span class="line">find . -type f -name "*.php" ! -perm 644 -print</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 将所有c文件合并到merge.txt中。其中-exec对匹配的每个文件执行一个操作。&#123;&#125;会被扩展为每个匹配的文件名。cp &#123;&#125; dir，就是将匹配的文件复制到dir目录下。-exec只能执行一条语句，但是可以把多条语句写到sh文件中。然后去执行这个文件</span><br><span class="line">find . -type f -name "*.c" -exec cat &#123;&#125; \; &gt;&gt; merge.txt</span><br><span class="line">echo prune::::::</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 指定在搜索的过程中忽略的项目。比如下面命令将忽略掉带boost，.vim，work的目录。</span><br><span class="line">find /root \( -name "*boost*" -prune -o -name "*.vim*" -prune -o -name "*work*" -prune \) \( -type d -print \)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> find还有-mtime和其他一些时间选项，可以用来匹配时间的</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="13-cat"><a href="#13-cat" class="headerlink" title="13. cat"></a>13. cat</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 多个空行合成一个空行</span><br><span class="line">cat -s test.txt</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> tr将多个'\n'合成一个'\n',因此，没有内容的行都会被删除</span><br><span class="line">cat test.txt|tr -s '\n'</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 输出行号，不会修改文件，只会修改stdout</span><br><span class="line">cat -n test.txt</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="14-xargs"><a href="#14-xargs" class="headerlink" title="14. xargs"></a>14. xargs</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 将多行文本合并成一行</span><br><span class="line">cat test.txt | xargs</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 将每一行文本转为多行。每行n个参数，默认用空格隔开，通过-d选项可以指定分隔符。一个文本如果有很多行，每一行都有可能被划分为多行，只要那一行有满足个数的分隔符</span><br><span class="line">cat test.txt | xargs -d . -n 2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 将args.txt里面的参数按照3个分组，作为参数传递给cecho.sh，不带-n选项的会全部传给它</span><br><span class="line">cat args.txt | xargs -n 3 ./cecho.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 如果需要固定参数，也可以使用xargs。如下-l是固定参数，-I选项后面的&#123;&#125;会被args.txt文件里面的参数替换掉,然后作为-p选项后面的参数。有多少个参数就会被替换多少次。</span><br><span class="line">cat args.txt | xargs -I &#123;&#125; ./cecho.sh -p &#123;&#125; -l</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> test.txt是一个3*4的参数文件。想把这个文件的参数按照3个一组的形式传给test.sh。首先一个xargs将文本转为一行。然后用空格分隔成3个一组。最后用-I来替换参数</span><br><span class="line">cat test.txt |xargs | xargs -d ' ' -n 3 | xargs -n 3 -I &#123;&#125; ./test.sh -p &#123;&#125; -l</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 统计所有c文件的行数,print0表示对find找到的数据用\0分割，因为我们没法预测分隔find命令输出结果的定界符是\n还是' '，很多文件中包含空格</span><br><span class="line"><span class="meta">#</span> xargs的-0选项表示将\0作为输入定界符。find，xargs搭配的时候应该总是用-print0</span><br><span class="line">find . -type f -name "*.sh" -print0 | xargs -0 wc -l</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> xargs只能将参数传给一个命令。使用带while的子shell形式，可以将一个参数传给一组命令.while里面的cat $arg可以改为任意行代码，并且随意使用arg。如果在while的子shell中使用的cd，改变了工作目录，cmd完全不知道工作目录发生了变化</span><br><span class="line">cat args.txt | (while read arg;do cat $arg;done) | echo</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="15-tr"><a href="#15-tr" class="headerlink" title="15. tr"></a>15. tr</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 大写转小写。合法的集合书写方式：ABD-&#125;，aA.,a-ce-x，a-c0-9</span><br><span class="line">echo "HELLO HAHA" | tr 'A-Z' 'a-z'</span><br><span class="line">echo "HELLO HAHA TEST" | tr [:upper:] [:lower:]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> -d会把标准输入中制定的字符集合删除</span><br><span class="line">echo "hello 123 wor34ld a" | tr -d '0-9'</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 将不在0-9，\n字符集里面的字符删除。-c是求补集用的</span><br><span class="line">echo -e 'hello 123   wor34ld  a\n d3fd3435' | tr -d -c '0-9 \n'</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 压缩字符,仅保留一个字符</span><br><span class="line">echo "haha xixi hiahia " | tr -s ' '</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 将test.txt文件里面的数字全部加起来。</span><br><span class="line">cat test.txt | xargs | echo $(tr ' ' '+') | bc</span><br></pre></td></tr></table></figure>
<ul>
<li>alumn : 字母和数字</li>
<li>alpha ：字母</li>
<li>cntrl ：控制（非打印）字符</li>
<li>digit ： 数字</li>
<li>graph ：图形字符</li>
<li>lower ： 小写字母</li>
<li>print ：可打印字符</li>
<li>punct ：标点符号</li>
<li>space ：空白字符</li>
<li>upper ：大写字母</li>
<li>xdigit ：十六进制字符</li>
</ul>
<hr>
<h2 id="16-md5sum与sha1sum"><a href="#16-md5sum与sha1sum" class="headerlink" title="16. md5sum与sha1sum"></a>16. md5sum与sha1sum</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 将md5sum保存到文件，然后使用-c选项来验证</span><br><span class="line">md5sum ./test.txt &gt; test.md</span><br><span class="line">md5sum -c test.md</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> sha1sum跟md5sum一样的使用方法</span><br><span class="line"><span class="meta">#</span> sha1sum的计算结果是40个字符的十六进制串。</span><br><span class="line"><span class="meta">#</span> md5sum的计算结果是32位字符的。</span><br><span class="line"><span class="meta">#</span> 计算一个目录里面所有文件的md5值，然后作比较</span><br><span class="line">find /root/leetcode_test -type f -print0 | xargs -0 md5sum &gt;&gt; leetcode_test.md5sum</span><br><span class="line">md5sum -c leetcode_test.md5sum</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="17-sort"><a href="#17-sort" class="headerlink" title="17. sort"></a>17. sort</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"><span class="meta">#</span> 排序去重</span><br><span class="line">sort test.txt | uniq &gt; sorted.txt</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 逆序</span><br><span class="line">sort -r test.txt</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 用数字排序</span><br><span class="line">sort -n file.txt</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 按月份排序</span><br><span class="line">sort -M months.txt</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 检验一个文件是否已经排好序</span><br><span class="line">sort -C sorted.txt</span><br><span class="line">if [ $? = 0 ];then</span><br><span class="line">echo Sorted;</span><br><span class="line">else</span><br><span class="line">echo unsorted;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 如果一行中存在多列，可以指定某一列进行排序.如下指定第二列进行排序</span><br><span class="line">sort -k 2 test.txt</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 如果一行只有一列，也可以指定某些位置的子串作为键，进行排序</span><br><span class="line">sort -k 2,3 test.txt</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 忽略排序文本的前导空格等字符.-b忽略前导空白字符，-d以字典序排序</span><br><span class="line">sort -bd test.txt</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 输出为一行，重复的被剔除</span><br><span class="line">sort -u test.txt</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 输出唯一行，有重复的不输出</span><br><span class="line">sort test.txt | uniq -until</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 指定一个键进行排序。这个键可以是字符串的任何位置.如下指定从第二个字符开始的两个字符作为键</span><br><span class="line">sort test.txt | uniq -s 2 -w 2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 删除所有指定的文件，-z选项用来指明字符串以结尾.否则字符串会被空格分隔</span><br><span class="line">uniq -z file.txt | xargs -0 rm</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 将ahebhaaa转换为4a1b1e2h形式。</span><br><span class="line">INPUT='ahebhaaa'</span><br><span class="line">OUTPUT=`echo $INPUT | sed 's/[^\n]/&amp;\n/g' | sed '/^$/d' |sort |uniq -c |tr -d '\n'`</span><br><span class="line"></span><br><span class="line">echo $OUTPUT</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="18-临时文件与随机数"><a href="#18-临时文件与随机数" class="headerlink" title="18. 临时文件与随机数"></a>18. 临时文件与随机数</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 用tempfile生成一个临时文件。tempfile只有在基于Debian的发布版里面有，如Ubuntu，Debian。改名了会在/tmp下创建一个文件</span><br><span class="line">temp_file=$(tempfile)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 下面的两个命令只是生成随机的名字，但是没有创建文件。tempfile会直接创建文件</span><br><span class="line"><span class="meta">#</span> 可以定制临时文件名.$RANDOM会随机生成一个数字</span><br><span class="line">temp_file="/tmp/file-$RANDOM"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 还可以用其他方法来创建.其中$$是当前运行脚本的进程ID</span><br><span class="line">temp_file="/tmp/var.$$"</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="19-分割文件"><a href="#19-分割文件" class="headerlink" title="19. 分割文件"></a>19. 分割文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"><span class="meta">#</span> 创建一个全为0，大小100k的文件.其中if指定输入文件，of指定输出文件，如果没有指定这些参数就会用</span><br><span class="line">dd if=/dev/zero bs=100k count=1 of=data.file</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 指定分割大小，将文件分割成多个文件,分割的文件是以字母为后缀的</span><br><span class="line"><span class="meta">#</span> -d可以将数字作为后缀</span><br><span class="line"><span class="meta">#</span> -a length可以指定后缀长度。</span><br><span class="line"><span class="meta">#</span> 除了K还可以是其他单位，M(MB),G(GB),c(byte),w(word)</span><br><span class="line">split -b 10k data.file</span><br><span class="line">split -b 10k data.file -d -a 4</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 指定文件名的前缀.如下split_file为文件名的前缀</span><br><span class="line">split -b 10k data.file -d -a 4 split_file</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 按照行数来分割文件，如下每个文件为10行</span><br><span class="line">split -l 10 data.file</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 更强大的分割工具：csplit。可以按照某些字符串来分割文件，指定分割后的后缀，包括长度，格式。</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="20-合并文件"><a href="#20-合并文件" class="headerlink" title="20. 合并文件"></a>20. 合并文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 目标是是将几个文件合并为一个，每个文件的第n行在新的文件里面还是第n行</span><br><span class="line"><span class="meta">#</span> 可以用-d选项来选择新文件里面的分隔符。\0相当于没有分隔符</span><br><span class="line">paste -d '\0' aaaa.txt bbbb.txt &gt; cccc.txt</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="21-切割字符串或文件名"><a href="#21-切割字符串或文件名" class="headerlink" title="21.切割字符串或文件名"></a>21.切割字符串或文件名</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">file_jpg='sample.fun.hehe.jpg'</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 可以使用%来提取文件名。</span><br><span class="line"><span class="meta">#</span> 该命令会删除%右边的通配符所匹配的字符串。通配符从右向左进行匹配。改名了属于非贪婪的，从最右边开始匹配最短的字符串</span><br><span class="line">name=$&#123;file_jpg%.*&#125;</span><br><span class="line">echo $name</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> %%会执行贪婪匹配，删除最长的匹配串</span><br><span class="line">name=$&#123;file_jpg%%.*&#125;</span><br><span class="line">echo $name</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> #可以用来提取后缀。执行的是最左往右的匹配。属于非贪婪匹配</span><br><span class="line">name=$&#123;file_jpg#*.&#125;</span><br><span class="line">echo $name</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 执行的是最左往右的匹配。属于贪婪匹配</span><br><span class="line">name=$&#123;file_jpg##*.&#125;</span><br><span class="line">echo $name</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="22-按照固定格式对目录下的所有文件进行重命名"><a href="#22-按照固定格式对目录下的所有文件进行重命名" class="headerlink" title="22. 按照固定格式对目录下的所有文件进行重命名"></a>22. 按照固定格式对目录下的所有文件进行重命名</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line">count=1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 将目录下的jpg和png文件统一命名为固定格式，同时保留他们的后缀名</span><br><span class="line">for img in *.jpg *png</span><br><span class="line">do</span><br><span class="line"><span class="meta">  #</span> 截取一下后缀</span><br><span class="line">  new=image-$count.$&#123;img##*.&#125;</span><br><span class="line"><span class="meta">  #</span> 这里进行重命名</span><br><span class="line">  mv "$img" "$new" 2&gt; /dev/null</span><br><span class="line"><span class="meta">  #</span> 判断一下重命名是否成功</span><br><span class="line">  if [ $? -eq 0 ];</span><br><span class="line">  then</span><br><span class="line">    echo "renaming $img to $new"</span><br><span class="line">    let count++</span><br><span class="line">  fi</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 其他的重命名工具.</span><br><span class="line"><span class="meta">#</span> 将文件名中的空格替换为_</span><br><span class="line">rename 's/ /_/g' *.jpg</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 将文件名改为大写字母</span><br><span class="line">rename 'y/a-z/A-Z/' *</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 将文件名中的.替换为_</span><br><span class="line">rename 's/\./_/g' *</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 将所有mp3文件放到一个目录下</span><br><span class="line">find . -type f -name "*.mp3" -exec mv &#123;&#125; /target_dir \;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> find与rename搭配</span><br><span class="line">find path -type f -exec rename 's/ /_/g' &#123;&#125; \;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="23-检查单词"><a href="#23-检查单词" class="headerlink" title="23. 检查单词"></a>23. 检查单词</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 使用look命令来检查单词.输出filepath中与word相关的词.如果不存在，返回状态&amp;?=1</span><br><span class="line">look word filepath</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 如果look不带字典参数就会使用默认的字典。默认字典在/usr/share/dict/中</span><br><span class="line">look word</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="24-交互输入自动化"><a href="#24-交互输入自动化" class="headerlink" title="24. 交互输入自动化"></a>24. 交互输入自动化</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">read -p "haha:" haha</span><br><span class="line">echo $haha</span><br><span class="line"></span><br><span class="line">read -p "xixi:" xixi</span><br><span class="line">echo $xixi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 比如有上面四行代码。我们可以用以下命令来实现交互式输入。</span><br><span class="line"><span class="meta">#</span> 交互式输入的意思就是，我们不需要一个参数一个参数的输入，可以一次性把需要的所有参数写在文件里面，或者通过echo来把参数给程序</span><br><span class="line">echo -e "haha\nxixi\n" | ./test/sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 如果参数是在文件里面，可以用重定向</span><br><span class="line">./test.sh &lt; input.data</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 可以用这种方法把shell code传给程序</span><br><span class="line">echo -e "\xeb\x1a..."</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 有时候需要根据程序的输出来确定我们需要输入什么。这时候可以用expect来实现自动化</span><br><span class="line"><span class="meta">#</span> 注意S脚本的开头是#!/usr/bin/expect.</span><br><span class="line"><span class="meta">#</span> 如果没有expect，就apt-get install一下</span><br><span class="line"><span class="meta">#</span>!/usr/bin/expect</span><br><span class="line">spawn ./test.sh # 指定自动化哪一个命令</span><br><span class="line">expect "haha:"</span><br><span class="line">send "xx</span><br><span class="line"></span><br><span class="line">expect "xixi:"</span><br><span class="line">send "zz</span><br><span class="line"></span><br><span class="line">expect eof # 自动化结束</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="25-生成任意大小的文件"><a href="#25-生成任意大小的文件" class="headerlink" title="25.生成任意大小的文件"></a>25.生成任意大小的文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> dd用来自动生成固定大小的文件。if指定输入文件，of指定输出文件，如果这两个参数没有指定就会用标准输入输出</span><br><span class="line"><span class="meta">#</span> bs指定块的大小</span><br><span class="line"><span class="meta">#</span> count指定生成多少块</span><br><span class="line"><span class="meta">#</span> dd命令可以用来测试内存的速度。命令运行完之后可以看得到</span><br><span class="line">dd if=/dev/zero of=junk.data bs=1M count=1</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="26-求文件的交集"><a href="#26-求文件的交集" class="headerlink" title="26. 求文件的交集"></a>26. 求文件的交集</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 会比较每一行，注意用来比较的文件是需要排序的</span><br><span class="line"><span class="meta">#</span> 输出会有三列，第一列是只在sorted中的行，第二列是只在test中的，最后是二者共有的。</span><br><span class="line"><span class="meta">#</span> 可以通过-1 -2 -3来指定删除输出的某些列</span><br><span class="line">comm sorted.txt test.txt</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="27-文件权限和所有权"><a href="#27-文件权限和所有权" class="headerlink" title="27. 文件权限和所有权"></a>27. 文件权限和所有权</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 修改文件权限</span><br><span class="line">chmod 755 filename</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 给所有权限类别增加可执行权限</span><br><span class="line">chmod a+x filename</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 给所有权限删除可执行权限</span><br><span class="line">chmod a-x filename</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 修改所有权</span><br><span class="line">chown user.group filename</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 设置粘滞位。使得只有目录的所有者才能删除目录中的文件，即使用户组和其他用户拥有足够的权限也不能执行该删除。t或T标志会出现在其他用户组权限的可执行标志位上，如/tmp一样</span><br><span class="line">chmod a+t directory_name</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 设置整个目录包括所有子文件的权限</span><br><span class="line">chmod 777 . -R</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 设置整个目录包括子文件的所有权</span><br><span class="line">chown user.group -R</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> setuid允许其他用户以文件所有者的身份来执行文件.他只能用在二进制文件上，不能用在脚本文件</span><br><span class="line">chmod +s executable_file</span><br><span class="line">chown root.root executable_file</span><br><span class="line">chmod +s executable_file</span><br><span class="line">./executable_file</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="28-设置文件不可修改"><a href="#28-设置文件不可修改" class="headerlink" title="28. 设置文件不可修改"></a>28. 设置文件不可修改</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 将文件设置为不可修改。用户密码一般存在/etc/shadow中，如果这个文件被设置为不可修改，那么用户就不能修改密码</span><br><span class="line">chattr +i file</span><br><span class="line"><span class="meta">#</span> 设置文件重新可写</span><br><span class="line">chattr -i file</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="29-批量生成空白文件"><a href="#29-批量生成空白文件" class="headerlink" title="29. 批量生成空白文件"></a>29. 批量生成空白文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 生成一个文件，如果文件存在就更新他的时间戳</span><br><span class="line"><span class="meta">#</span> touch filename</span><br><span class="line"><span class="meta">#</span> 批量生成文件。&#123;1..100&#125;会被扩展为1到100，注意花括号里面是两个点</span><br><span class="line">for name in &#123;1..100&#125;.txt</span><br><span class="line">do</span><br><span class="line">	touch $name</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="30-链接文件"><a href="#30-链接文件" class="headerlink" title="30. 链接文件"></a>30. 链接文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 创建链接</span><br><span class="line">ln -s target symbolic-link-name</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 查看链接文件的源文件</span><br><span class="line">ls -l | grep "^l" | awk '&#123;print $8&#125;'</span><br><span class="line">find . -type l -print0</span><br><span class="line"><span class="meta">#</span> 最好的方式是</span><br><span class="line">readlink symbolic-link-name</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="31-统计文件类型数量"><a href="#31-统计文件类型数量" class="headerlink" title="31. 统计文件类型数量"></a>31. 统计文件类型数量</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">if [ $# -ne 1 ];</span><br><span class="line">then</span><br><span class="line">  echo $0 basepath;</span><br><span class="line">  echo</span><br><span class="line">fi</span><br><span class="line">path=$1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 声明一个关联数组</span><br><span class="line">declare -A statarray</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 从输入中获取每一行</span><br><span class="line">while read line</span><br><span class="line">do</span><br><span class="line">  ftype=`file -b "$line"`</span><br><span class="line">  let statarray["$ftype"]++</span><br><span class="line"><span class="meta">  #</span> 这里需要两个&lt;，并且是分开的。&lt;(find $path -type f -print)相当于一个文件filename。只不过现在用子进程来代替文件名</span><br><span class="line">done&lt; &lt;(find $path -type f -print)</span><br><span class="line"></span><br><span class="line">echo ========== File types and counts ============</span><br><span class="line">for ftype in "$&#123;!statarray[@]&#125;";</span><br><span class="line">  do</span><br><span class="line">  echo $ftype : $&#123;statarray["$ftype"]&#125;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="32-生成序列"><a href="#32-生成序列" class="headerlink" title="32. 生成序列"></a>32. 生成序列</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 生成1-100</span><br><span class="line">seq 100</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="33-head-tail"><a href="#33-head-tail" class="headerlink" title="33. head, tail"></a>33. head, tail</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 打印前n行</span><br><span class="line">head -n 5 test.txt</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 打印除了最后5行外的其他行</span><br><span class="line">head -n -5 test.txt</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 打印最后10行</span><br><span class="line">tail file</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 打印最后5行</span><br><span class="line">tail -n 5 file</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 打印除了前N行之外的所有行</span><br><span class="line">tail -n +(N+1)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 如果文件是不断增长的，为了保持最新数据，可以用-f选项</span><br><span class="line">tail -f /var/log/messages</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> tail可以跟踪一个进程，当进程断了之后tail也跟着断</span><br><span class="line">tail -f file --pid $PID</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="34-目录切换"><a href="#34-目录切换" class="headerlink" title="34. 目录切换"></a>34. 目录切换</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 将路径入栈</span><br><span class="line">pushd /var/www</span><br><span class="line"><span class="meta">#</span> 显示栈中的</span><br><span class="line">dirs</span><br><span class="line"><span class="meta">#</span> 想要切换到某一个路径时，用+N。其中编号是从0开始的。</span><br><span class="line">pushd +3</span><br><span class="line"><span class="meta">#</span> 移除最近添加的路径，并切换到这个路径popd</span><br><span class="line">popd</span><br><span class="line">popd +no # 可以移除特定目录</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="35-计算文件，字符，单词数"><a href="#35-计算文件，字符，单词数" class="headerlink" title="35. 计算文件，字符，单词数"></a>35. 计算文件，字符，单词数</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 统计行数</span><br><span class="line">wc -l file</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> stdin作为输入</span><br><span class="line">cat file | wc -l</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 统计单词</span><br><span class="line">wc -w file</span><br><span class="line">cat file | wc -w</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 统计字符数</span><br><span class="line">wc -c file</span><br><span class="line">cat file | wc -c</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 不带参数的会输出文件的行数，单词数和字符数</span><br><span class="line">wc file</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 输出最长行的长度</span><br><span class="line">wc file -L</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="36-grep"><a href="#36-grep" class="headerlink" title="36. grep"></a>36. grep</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 匹配一个或多个文件</span><br><span class="line">grep match_pattern filename1 filename2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 从stdin读取</span><br><span class="line">echo -e "this is a word</span><br><span class="line">line" | grep word</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 重点标记匹配到的单词</span><br><span class="line">grep word filename --color=auto</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 为了在grep中使用正则表达式，可以加上-E选项或者是egrep</span><br><span class="line">grep -E "[a-z]+"</span><br><span class="line">egrep "[a-z]+"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 只输出文件中匹配到的文本部分，使用-o</span><br><span class="line">echo this is a line. | grep -o -E "[a-z]+\." # 只会输出line.</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 打印除包含pattern的行之外的所有行,-v选项将结果进行反转</span><br><span class="line">grep -v pattern file</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> -c只是统计匹配的行的数量，而不是匹配的次数</span><br><span class="line"> echo -e "1 2 3 4\nhello\n 5 6" | egrep -c "[0-9]"  # 只会输出2</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span> 为了统计匹配项的数量，可以使用：</span><br><span class="line">echo -e "1 2 3 4\nhello\n 5 6" | egrep -o "[0-9]" | wc -l</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 打印出匹配的行号</span><br><span class="line">grep linux -n sample.txt</span><br><span class="line">grep -l linux sample1.txt sample2.txt # 如果匹配多个文件，每个文件和他们的行号都会输出</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 输出匹配在每行的偏移.-o和-b一般是一起搭配使用的</span><br><span class="line">echo gun is not unix | grep -b -o "not"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 递归搜索。.表示当前目录</span><br><span class="line">grep "test_function()" . -R -n</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 匹配的时候忽略大小写</span><br><span class="line">echo hello world | grep -i "HELLO"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 可以用#匹配多个样式</span><br><span class="line">grep -e "pat" -e "pat2"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 匹配多个样式的方法还可以是在文件中写下多个样式，然后让grep去读取文件</span><br><span class="line">grep -f pat_file source_filename</span><br><span class="line">echo hello this is cool | grep -f pat_file</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 在匹配的时候可以排除或者包括指定的文件.如下是递归在所有c和cpp文件中查找</span><br><span class="line">grep "main()" . -R --include *.&#123;c,cpp&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 搜索中排除所有README文件.排除目录用--exclude-dir。要用文件中读取所需排除的文件列表，使用--exclude-from FILE</span><br><span class="line">grep "main()" . -r --exclude "READEME"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> grep输出以0值字节作为终结符的文件名，用-Z选项，一般-Z和-l结合使用</span><br><span class="line">grep "text" file* -lZ | xargs -0 rm</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> grep静默输出能返回一个值.检查文本是否包含指定模式</span><br><span class="line">grep -q $pat $filename</span><br><span class="line">if [ $? -eq 0 ];</span><br><span class="line">then</span><br><span class="line">echo 'exists in the file'</span><br><span class="line">else</span><br><span class="line">echo 'does not in the file'</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 打印匹配行之后的3行</span><br><span class="line">seq 10 | grep 5 -A 3</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 打印匹配行之前的3行</span><br><span class="line">seq 10 | grep 5 -B 3</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 打印匹配之前和之后3行</span><br><span class="line">seq 10 | grep 5 -C 3</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="37-cut"><a href="#37-cut" class="headerlink" title="37. cut"></a>37. cut</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> N- 从第N个到行尾</span><br><span class="line"><span class="meta">#</span> N-M 从第N到M个</span><br><span class="line"><span class="meta">#</span> -M 从第1个到M个</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> -b 字节</span><br><span class="line"><span class="meta">#</span> -c 字符</span><br><span class="line"><span class="meta">#</span> -f 字段</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 打印前2个字符,如果c换成b，就是用字节作为计数单位</span><br><span class="line">cut file.txt -c-2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 如果输出多个字段，要指定分界符</span><br><span class="line">cut filename -c1-3,6-9 --output-delimiter ","</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 统计单词数量</span><br><span class="line">egrep -o [[:alpha:]]" $filename | awk '&#123;count[$0]++&#125;</span><br><span class="line">END&#123;</span><br><span class="line">for(ind in count)&#123;printf("%s,%d",ind,count[ind]);&#125;</span><br><span class="line">&#125;'</span><br><span class="line"><span class="meta">#</span> egrep -o [[:alpha:]]" $filename这个用来分割单词，每个单词一行</span><br><span class="line"><span class="meta">#</span> awk会自动处理每一行文本，所以不需要循环</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="38-sed"><a href="#38-sed" class="headerlink" title="38. sed"></a>38. sed</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 从文件读取，替换第一个匹配串</span><br><span class="line">sed 's/pattern/replace_string' file</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 从stdin读取，直接替换到第一个匹配串</span><br><span class="line">echo this this this this | sed 's/this/THIS/'</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 使用-i选项可以直接将修改的结果写入到文件，不需要在重定向</span><br><span class="line">sed -i 's/text/replace/' file</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 替换所有匹配串</span><br><span class="line">echo thisthis this|sed 's/this/THIS/g'</span><br><span class="line">sed 's/pattern/replace/g' file</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 替换从第N个开始的匹配串.如下从第二个匹配串开始替换</span><br><span class="line">sed 's/this/THIS/2g' file</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> sed中的/是分界符。可以使用任意的分界符，比如 s:text:replace:g</span><br><span class="line"><span class="meta">#</span> 如果定界符出现在样式内部，就要用\进行转义</span><br><span class="line"><span class="meta">#</span> 移除空白行 /pattern/d.空白行可以用^$匹配</span><br><span class="line">sed '/^$/d' file</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 匹配到的串可以用&amp;代替他.如下会用[]把每个单词包裹起来</span><br><span class="line">echo this is an example | sed 's/\w\+/[&amp;]/g'</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 可以用标记\N来对应匹配到的字符串.如下 分别匹配([A-Z]+)和([a-z]+)匹配的串。然后将他们逆序一下</span><br><span class="line">echo seven SEVEN | sed 's/\([a-z]\+\) \([A-Z]\+\)/ /'</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 组合多个sed命令。</span><br><span class="line"><span class="meta">#</span> 用管道的方式sed 'expression' | sed 'expression'等价于</span><br><span class="line"><span class="meta">#</span> sed 'expression; expression'</span><br><span class="line"><span class="meta">#</span> 可以用双引号来引用变量</span><br><span class="line">text=hello</span><br><span class="line">echo hello world|sed "s/$text/HELLO/"</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="39-awk"><a href="#39-awk" class="headerlink" title="39. awk"></a>39. awk</h2><p>awk脚本的结构基本如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk 'BEGIN&#123; print "start" &#125; pattern &#123; commands &#125; END &#123; print "end" &#125;' file</span><br></pre></td></tr></table></figure>
<p>awk也能读取stdin的内容。一个awk脚本通常由3部分构成：<code>BEGIN</code>语句块，<code>END</code>语句块和能够使用<code>模式匹配</code>的通用语句块。这3部分是可选的，它们中任何一部分都可以不出现在脚本中。脚本通常会被包含在单引号或者双引号中：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk 'BEGIN &#123;statments&#125; &#123;statments&#125; END &#123;end statments&#125;'</span><br></pre></td></tr></table></figure>
<p>或者也可以使用</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk "BEGIN &#123;statments&#125; &#123;statments&#125; END &#123; end statements&#125;"</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk 'BEGIN &#123;i=0&#125; &#123;i++&#125; END&#123;print i&#125;' filename</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk "BEGIN &#123;i=0&#125; &#123;i++&#125; END&#123;print i&#125;" filename</span><br></pre></td></tr></table></figure>
<p>awk有很多内建的字符串控制函数：</p>
<ul>
<li>length(string): 返回字符串的长度</li>
<li>index(string, search_string): 返回search_string在字符串中出现的位置</li>
<li>split(string, array, delimiter): 用定界符生成一个字符串列表，并将其存入数组</li>
<li>substr(string, start-position, end-position): 在字符串中用字符起止偏移量生成子串，并返回改子串</li>
<li>sub(regex, replacement_str, string)：将正则表达式匹配到的第一处内容替换成replacement_str</li>
<li>gsub(regex, replacement_str, string): 和sub()类似，不过该函数会替换正则表达式匹配到的所有内容。</li>
<li>match(regex, string): 检查正则表达式是否呢在那个匹配字符串，如果能够匹配，返回非0值，否则返回0。match()有两个相关的特殊变量，分别是RSTART和RLENGTH。变量RSTART包含正则表达式所匹配内容的起始位置，而变量RLENGTH包含正则表达式所匹配内容的长度。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> awk首先回去执行BEGIN语句块。BEGIN语句块一般用来初始化变量，或者打印一下表头。不会去执行文本</span><br><span class="line"><span class="meta">#</span> 然后在pattern &#123;commands&#125; 里面执行文本。每一行文本都会执行相同的步骤，相当于循环</span><br><span class="line"><span class="meta">#</span> END &#123;commands&#125; 在文本结束后执行。</span><br><span class="line"><span class="meta">#</span> 这些语句块都是可以随意删掉的，不一定要全部都写</span><br><span class="line">echo -e "line1\nline2" | awk 'BEGIN&#123; print "start"&#125; &#123;print&#125; END&#123;print "END"&#125;'</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 使用print要注意，如果是用逗号隔开，那么输出是用空格隔开的；双引号是连接符</span><br><span class="line"><span class="meta">#</span> 比如下面的输出是用空格隔开的。echo只会输出一行，所以这个awk只会执行一次</span><br><span class="line">echo | awk '&#123;var1="v1";var2="v2; print var1,var2"&#125;'</span><br><span class="line">echo | awk '&#123;var1="v1";var2="v2; print var1"-"var2"&#125;'</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> NR ： 记录数量，在执行时相当于行号</span><br><span class="line"><span class="meta">#</span> NF ： 表示字段数量，在执行过程中对应于当前的字段数。</span><br><span class="line"><span class="meta">#</span> FS : 定界符</span><br><span class="line"><span class="meta">#</span> $0 : 当前行的内容</span><br><span class="line"><span class="meta">#</span> $1 : 第一个字段</span><br><span class="line"><span class="meta">#</span> $2 : 第二个字段</span><br><span class="line"><span class="meta">#</span> 如下，注意逗号和双引号的使用。printf函数跟c语言中的同名函数一样，可以替换print</span><br><span class="line">echo -e "line1 f2 f3\nline2 f4 f5" | awk '&#123;print "line no:"NR",No of fields:"NF,20. "$0="$0,"$1="$1,"$2="$2,"$3="$3&#125;'</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 打印第2和第3行</span><br><span class="line">awk '&#123;print $3,$2&#125;' file</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 统计行数</span><br><span class="line">awk 'END&#123;print NR&#125;' file</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 累加第一个字段的值</span><br><span class="line">seq 5 | awk 'BEGIN&#123;sum=0; print "Sum:"&#125;</span><br><span class="line">&#123;print $1"+"; sum+=$1 &#125; END&#123;print "=="; print sum&#125;'</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 将外部变量传递给awk.要传递的变量放在素有语句块之后，用空格隔开</span><br><span class="line">var1="Variable1"; var2="Variable2"</span><br><span class="line">echo | awk '&#123;print v1,v2&#125;' v1=$var1 v2=$var2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 用getline读取行</span><br><span class="line">seq 5 | awk 'BEGIN &#123; getline; print "first line",$0 &#125; &#123; print $0 &#125;'</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 用样式来过滤行。只有匹配的行才会被处理</span><br><span class="line"><span class="meta">#</span> awk 'NR&lt;5' 行号小于5的行</span><br><span class="line"><span class="meta">#</span> awk '/linux/' 匹配到linux的行，也可以用正则</span><br><span class="line"><span class="meta">#</span> awk '!/linux/' 不包含linux的行</span><br><span class="line">seq 5 | awk '!/3/ &#123;print $0&#125;' # 不包含3的行</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 设置定界符</span><br><span class="line">awk -F: '&#123;print $NF&#125;' /etc/passwd</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> awk读取命令输出</span><br><span class="line">echo | awk '&#123;"grep root /etc/passwd" | getline cmdout; print cmdout&#125;'</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> awk中的循环.注意awk外面是单引号，里面要用双引号</span><br><span class="line">echo | awk '&#123; for(i=0;i&lt;10;i++) &#123;print i&#125;</span><br><span class="line">array[0]="bad";array[1]=123; array["haha"]="xixi"; array[2]="dhfkd";array["xixi"]="hoho";</span><br><span class="line">for(i in array)&#123;print array[i]&#125;&#125;'</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="40-文本替换"><a href="#40-文本替换" class="headerlink" title="40. 文本替换"></a>40. 文本替换</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sed 's/pat/replace/g' filename</span><br><span class="line"><span class="meta">#</span> sed替换stdin</span><br><span class="line">stdin | sed 's/pat/replace/g'</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> sed可以使用双引号，使用双引号的时候可以用变量</span><br><span class="line">p=pattern</span><br><span class="line">r=replaced</span><br><span class="line">echo 'line containing spattern' | sed "s/$p/$r/g"</span><br><span class="line"></span><br><span class="line">echo 11 abc 111 this 9 file contains 111 11 88 numbers 0000 | sed 's/[0-9]\&#123;3\&#125;/NUMBER/g'</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="41-迭代行，单词，字符"><a href="#41-迭代行，单词，字符" class="headerlink" title="41. 迭代行，单词，字符"></a>41. 迭代行，单词，字符</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">while read line;</span><br><span class="line">do</span><br><span class="line"><span class="meta">  #</span> 迭代一行的每个单词</span><br><span class="line">  for word in $line;</span><br><span class="line">    do</span><br><span class="line">      # $&#123;#word&#125;返回字符串的长度</span><br><span class="line">      for((i=0;i&lt;$&#123;#word&#125;;i++));</span><br><span class="line">      do</span><br><span class="line">      # 使用特殊记法$&#123;string:start_position:No_of_characters&#125;来获取一个字符串里面固定位置的某几个字符。这个就是字符串子串提取技术</span><br><span class="line">      echo $&#123;word:i:1&#125;</span><br><span class="line">    done</span><br><span class="line">  done</span><br><span class="line">done &lt; test.txt</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="42-合并文件"><a href="#42-合并文件" class="headerlink" title="42. 合并文件"></a>42. 合并文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 按照行来合并文件,file2紧接着file1</span><br><span class="line">cat file1 file2 file3</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 按列来合并。默认定界符是制表符，也可以用-d来指定分界符。file1，file2，file3的第n行都在合并之后的第n行，以此类推</span><br><span class="line">paste file1 file2 file3</span><br><span class="line">paste file1 file2 -d ","</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="43-打印不同行或者样式之间的文本"><a href="#43-打印不同行或者样式之间的文本" class="headerlink" title="43. 打印不同行或者样式之间的文本"></a>43. 打印不同行或者样式之间的文本</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 打印从M行到N行的所有文本.注意是双等好。而且是从1开始计数的，cut也是从1开始计数</span><br><span class="line">awk 'NR==M,NR==N' filename</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 打印处于start_pattern与end_pattern之间的文本.注意这里打印的文本，不是以行为单位的，而是以整个文本为单位的。比如，第一行匹配start_pattern，最后一行匹配end_pattern，那么就会输出所有行</span><br><span class="line">awk '/start_pattern/,/end_pattern/' filename</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="44-逆序打印行"><a href="#44-逆序打印行" class="headerlink" title="44. 逆序打印行"></a>44. 逆序打印行</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 逆序打印行</span><br><span class="line">echo abcdef | rev</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 把一句中的每个单词逆序.tac的默认分隔符是\n，我们可以用-s指定分隔符</span><br><span class="line">sentence='this is line from sentence'</span><br><span class="line">echo $sentence | rev | tr ' ' '\n' | tac | tr '\n' ' ' | rev</span><br><span class="line">echo $sentence | rev | tr ' ' '\n' | rev | tr '\n' ' '</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 为了看出rev和tac的区别。</span><br><span class="line">seq 10 | rev</span><br><span class="line">seq 10 | tac</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 如果使用awk来实现的话,需要用到关联数组来存储</span><br><span class="line">seq 10 | awk '&#123;lifo[NR]=$0; lno=NR&#125;</span><br><span class="line">END&#123;for(;lno&gt;-1;lno--)&#123;print lifo[lno];&#125;&#125;'</span><br></pre></td></tr></table></figure>
        </section>
        <hr/>
        <nav class="pagination" style="width:auto" role="pagination">
            
            <a data-pjax class="newer-posts" href="/2017/06/20/Median-of-Two-Sorted-Arrays/">← Prev Post</a>
            
            <a class="share-button" data-original-title title>Share this Post</a>
            
        </nav>
        <br/>
        <br/>
        <section id="comment">
            <div id="comment-box"></div>
        </section>


    </article>
</main>


  
<footer class="site-footer">
    
    <div class="inner">
        <section class="copyright"><a href="/"></a> &copy; pan D.wei's Blog 2016</section>
    </div>
</footer>
</div>
</div><!-- /scroller -->

</div><!-- /pusher -->
</div><!-- /container -->
</div>

<!-- Easter eggs -->

<div class="egg animated">
    <a id="close-button" href="#">X</a>
    <div class="block">
        <div class="loading">
            <span class="ball1"></span>
            <span class="ball2"></span>
        </div>
    </div>
</div>

  
<script src="//cdn.staticfile.org/jquery/1.11.0/jquery.min.js"></script>
<script>
    if (!window.jQuery) {
        var script = document.createElement('script');
        script.src = "/js/jquery.min.js";
        document.body.appendChild(script);
    }
</script>
<script type="text/javascript" src="/js/lean-analystics.js"></script>
<script type="text/javascript" src="/js/lib.js"></script>
<script type="text/javascript" src="/js/main.js"></script>







</body>
</html>
