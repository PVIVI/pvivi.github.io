<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
  <title>nsq源码阅读-NSQD | pan D.wei&#39;s Blog</title>
  <meta name="description" content="" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="MobileOptimized" content="320" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" type="text/css" href="/css/component.css" />
  <link rel="stylesheet" type="text/css" href="/css/screen.css" />
  <meta name="generator" content="pan D.wei's Blog">
  <script src="http://static.duoshuo.com/embed.js"></script>
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("WlEt6BpzYCC3DYc6BA8Gm34p-gzGzoHsz", "j8XNnOegrpFwzRM8seXAekgf");</script>

  
  
  

  
  
</head>
<body>
<div class="container">
    <div class="mp-pusher" id="mp-pusher">
        <i id="scroll-up" class="fa fa-angle-up"></i>
        <nav id="mp-menu" class="mp-menu">
            <div class="mp-level">
                <a data-pjax class="back-home" style="font-size: 20px" href="/"><h2 ><i class="fa fa-home"></i>
                        Home</h2></a>
                <ul class="first-level">
                    <li>
                        <a class="fa fa-archive" href="#"><i class="fa fa-angle-left">
                            </i>&nbsp;&nbsp;Archive</a>
                        <div class="mp-level page-list">
                            <h2 ><i class="fa fa-archive"></i>
                                Archive</h2>
                            <a class="mp-back" href="#">back</a>
                            <form id="search-form" action="">
                                <input type="text" class="search search-archive" placeholder="Search.."/>
                            </form>
                            <ul>
                                <div class="mp-scroll">
                                
                                <li class="search-archive-li">
                                    <a href="/2018/05/22/nsq源码阅读-NSQD/">nsq源码阅读-NSQD</a>
                                </li>
                                
                                <li class="search-archive-li">
                                    <a href="/2018/04/07/用redis构建分布式锁/">用redis构建分布式锁</a>
                                </li>
                                
                                <li class="search-archive-li">
                                    <a href="/2018/03/16/虚拟内存/">虚拟内存</a>
                                </li>
                                
                                <li class="search-archive-li">
                                    <a href="/2017/12/27/API限流策略与Tocken-Bucket算法实现/">API限流策略与Tocken Bucket算法实现</a>
                                </li>
                                
                                <li class="search-archive-li">
                                    <a href="/2017/11/25/使用nginx分流进行A-B测试/">使用nginx分流进行A/B测试</a>
                                </li>
                                
                                <li class="search-archive-li">
                                    <a href="/2017/06/20/Median-of-Two-Sorted-Arrays/">Median of Two Sorted Arrays</a>
                                </li>
                                
                                <li class="search-archive-li">
                                    <a href="/2016/03/31/Linux-Command/">Linux Command</a>
                                </li>
                                
                                </div>
                            </ul>
                        </div>
                    </li>
                    <li>
                        <a class="fa fa-copy" href="#"><i class="fa fa-angle-left">
                            </i>&nbsp;&nbsp;Categories</a>

                        <div class="mp-level page-list">
                            <h2 ><i class="fa fa-copy"></i>
                                Categories</h2>
                            <a class="mp-back" href="#">back</a>
                            <form id="search-form" action="">
                                <input type="text" class="search search-category" placeholder="Search.."/>
                            </form>
                            <ul>
                                <div class="mp-scroll">
                                
                                <li class="search-category-li">
                                    <a href="/categories/learning/">&nbsp;&nbsp;&nbsp;learning</a>
                                    <small>6</small>
                                </li>
                                
                                </div>
                            </ul>
                        </div>
                    </li>
                    <li>
                        <a class="fa fa-tags" href="#"><i class="fa fa-angle-left">
                            </i>&nbsp;&nbsp;Tags</a>
                        <div class="mp-level page-list">
                            <h2 ><i class="fa fa-tags"></i>
                                Tags</h2>
                            <a class="mp-back" href="#">back</a>
                            <form id="search-form" action="">
                                <input type="text" class="search search-tag" placeholder="Search.."/>
                            </form>
                            <ul>
                                <div class="mp-scroll">
                                
                                <li class="search-tag-li">
                                    <a href="/tags/MQ/">&nbsp;&nbsp;&nbsp;MQ</a>
                                    <small>1</small>
                                </li>
                                
                                <li class="search-tag-li">
                                    <a href="/tags/OS/">&nbsp;&nbsp;&nbsp;OS</a>
                                    <small>1</small>
                                </li>
                                
                                <li class="search-tag-li">
                                    <a href="/tags/algorithm/">&nbsp;&nbsp;&nbsp;algorithm</a>
                                    <small>3</small>
                                </li>
                                
                                <li class="search-tag-li">
                                    <a href="/tags/cache/">&nbsp;&nbsp;&nbsp;cache</a>
                                    <small>2</small>
                                </li>
                                
                                <li class="search-tag-li">
                                    <a href="/tags/linux/">&nbsp;&nbsp;&nbsp;linux</a>
                                    <small>4</small>
                                </li>
                                
                                <li class="search-tag-li">
                                    <a href="/tags/nsq/">&nbsp;&nbsp;&nbsp;nsq</a>
                                    <small>1</small>
                                </li>
                                
                                <li class="search-tag-li">
                                    <a href="/tags/shell/">&nbsp;&nbsp;&nbsp;shell</a>
                                    <small>1</small>
                                </li>
                                
                                </div>
                            </ul>
                        </div>
                    </li>
                    
                    <li><a class="fa fa-user" href="/about">&nbsp;&nbsp;&nbsp;About me</a></li>

                </ul>

            </div>
        </nav>
        <div id="pjax">
            <div class="pjax-hidden" style="display: none">
                
                    <a  data-pjax href="/2018/05/22/nsq源码阅读-NSQD/">nsq源码阅读-NSQD</a>
                
                    <a  data-pjax href="/2018/04/07/用redis构建分布式锁/">用redis构建分布式锁</a>
                
                    <a  data-pjax href="/2018/03/16/虚拟内存/">虚拟内存</a>
                
                    <a  data-pjax href="/2017/12/27/API限流策略与Tocken-Bucket算法实现/">API限流策略与Tocken Bucket算法实现</a>
                
                    <a  data-pjax href="/2017/11/25/使用nginx分流进行A-B测试/">使用nginx分流进行A/B测试</a>
                
                    <a  data-pjax href="/2017/06/20/Median-of-Two-Sorted-Arrays/">Median of Two Sorted Arrays</a>
                
                    <a  data-pjax href="/2016/03/31/Linux-Command/">Linux Command</a>
                
                
                    <a data-pjax href="/categories/learning/">&nbsp;&nbsp;learning</a>
                
                
                    <a data-pjax href="/tags/MQ/">&nbsp;&nbsp;MQ</a>
                
                    <a data-pjax href="/tags/OS/">&nbsp;&nbsp;OS</a>
                
                    <a data-pjax href="/tags/algorithm/">&nbsp;&nbsp;algorithm</a>
                
                    <a data-pjax href="/tags/cache/">&nbsp;&nbsp;cache</a>
                
                    <a data-pjax href="/tags/linux/">&nbsp;&nbsp;linux</a>
                
                    <a data-pjax href="/tags/nsq/">&nbsp;&nbsp;nsq</a>
                
                    <a data-pjax href="/tags/shell/">&nbsp;&nbsp;shell</a>
                
                <a data-pjax class="fa fa-user" href="/about">&nbsp;&nbsp;&nbsp;About me</a>
            </div>
            <nav class="nexus">
                <li  style="border-left: 1px solid #c6d0da;">
                    <a id="trigger" href="#"><i class="fa fa-bars"></i></a>
                </li>
                <li ><a id="nexus-back" data-pjax href="/">pan D.wei&#39;s Blog</a></li>
                
                <div id="nav-container">
                    <div class="post-navbar" style="line-height: 63px;display:none">
                        <li id="navbar-title"><a href="#">nsq源码阅读-NSQD</a></li>
                        <li id="navbar-toc" style="border-left: none">
                            <a style="padding-right: 15px">
                                <span id="toc-content" >Introduction</span><i class="fa fa-chevron-down" ></i>
                            </a>
                            <div class="hidden-box">
                                <ul id="toc"></ul>
                            </div>
                        </li>
                    </div>
                </div>
                
            </nav>

            <div class="scroller">
            <div class="scroller-inner">

<!-- -->
<!--<body class="post-template">-->
<!---->
  
<main class="content" role="main">
    <article class="post" >
    <span class="post-meta">
                  <div class="tag-tile">
                      
                      
                      <a data-pjax href='/tags/nsq/' style='color:#D5D5D5'>nsq</a>
                      
                      <a data-pjax href='/tags/MQ/' style='color:#D5D5D5'>MQ</a>
                      
                      
                  </div>
                <h1 class="post-title" style="margin: 14px 0;color:#50585D">nsq源码阅读-NSQD</h1>

                    <div class="post-meta">
                        Post on<span class="fa fa-clock-o"></span>
                        <time datetime="2018-05-22T01:11:17.000Z"
                              itemprop="datePublished">2018-05-22</time>
                        
                        <span class="post-meta-divider">|</span>     
                        Views<span class="fa fa-eye"></span>
                        <x class="leancloud-visitors-count"></x>
                    </div>     
    </span>
        <section id="/2018/05/22/nsq源码阅读-NSQD/" class="post-content">
            <p><strong>NSQ</strong> 是实时的分布式消息处理平台，其设计的目的是用来大规模地处理每天数以十亿计级别的消息。NSQ 具有<strong>分布式</strong>和<strong>去中心化</strong>拓扑结构，该结构具有无单点故障、故障容错、高可用性以及能够保证消息的可靠传递的特征。上面是NSQ的官方介绍，简单的来说，NSQ就是一个消息队列(MQ)。由于笔者的工作环境大量用到NSQ，为了理解在使用过程中遇到的一些坑，也因为出于兴趣，因此研究一下nsq的源码。<br><a id="more"></a></p>
<h2 id="1-NSQ组件简介"><a href="#1-NSQ组件简介" class="headerlink" title="1. NSQ组件简介"></a>1. NSQ组件简介</h2><p>实际上，NSQ组件包括nsqd，nsqlookupd，nsqadmin。nsqd主要用于处理服务端与客户端之间的消息收发，是NSQ的关键组件。当我们将nsqd运行起来之后，它将监听两个端口，默认配置是4150和4151，前者为客户端提供了TCP服务，后者则提供了HTTP API服务。nsqd可以单独运行不依赖于其他NSQ组件，但是我们一般会与nsqlookupd搭配使用。nsqlookupd主要用于管理NSQ的网络拓扑信息。客户端通过查询nsqlookupd可以发现新的nsqd节点，新的topic或者channel信息。nsqadmin是一个web服务，它为用户提供了可视化界面用于实时的查询nsq集群中不同消息队列的详细信息。</p>
<h2 id="2-NSQD"><a href="#2-NSQD" class="headerlink" title="2. NSQD"></a>2. NSQD</h2><p>nsqd作为NSQ的关键组件，承担了系统中最重要的消息分发功能，因此接下的内容主要围绕nsqd展开。下图是NSQ官方文档上的一张gif图，为我们描绘的是nsqd的整体架构以及消息传递过程。不同的消息队列在NSQ中是通过topic定义的，在NSQ实例中，我们可以定义多个队列，相当于多个topic，每个topic我们可以理解为是一个队列，而每个队列下可以定义多个管道，即多个channel。客户端通过订阅channel，可以消费队列中的消息。可以有多个客户端消费同一个channel，由nsqd保证将消息传递到至少一个客户端中。因为队列中的每一条消息都会分发到该队列关联的所有channel中，因此，channel实际上起到了分隔业务的作用，不同的业务类型通过订阅同一个topic的不同channel可以做到互不干扰。</p>
<p><img src="https://f.cloud.github.com/assets/187441/1700696/f1434dc8-6029-11e3-8a66-18ca4ea10aca.gif" alt=""></p>
<h3 id="2-1-NSQD源码宏观"><a href="#2-1-NSQD源码宏观" class="headerlink" title="2.1 NSQD源码宏观"></a>2.1 NSQD源码宏观</h3><p>获取到NSQ源码包之后，我们先看一下NSQ的目录结构。为便于查看，下面是只保留目录的项目结构，其余的文件都没有展示出来。其中nsqd，nsqlookupd，nsqadmin三个目录存放了三个组件的主要代码。但是，三个组件的入口都不在各自的目录中，即这三个目录都不是main package。main package在apps目录下。比如nsq/apps/nsqd为nsqd的main package，而nsq/nsqd为nsqd的nsqd package。NSQ提供了make编译方式，直接在nsq目录下执行make会在根目录下生成一个build目录，编译生成的可执行文件都存在里面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">└── nsq</span><br><span class="line">    ├── apps</span><br><span class="line">    │   ├── nsq_pubsub</span><br><span class="line">    │   ├── nsq_stat</span><br><span class="line">    │   ├── nsq_tail</span><br><span class="line">    │   ├── nsq_to_file</span><br><span class="line">    │   ├── nsq_to_http</span><br><span class="line">    │   ├── nsq_to_nsq</span><br><span class="line">    │   ├── nsqadmin</span><br><span class="line">    │   ├── nsqd</span><br><span class="line">    │   ├── nsqlookupd</span><br><span class="line">    │   └── to_nsq</span><br><span class="line">    ├── bench</span><br><span class="line">    │   ├── bench_channels</span><br><span class="line">    │   ├── bench_reader</span><br><span class="line">    │   └── bench_writer</span><br><span class="line">    ├── contrib</span><br><span class="line">    ├── internal</span><br><span class="line">    │   ├── app</span><br><span class="line">    │   ├── auth</span><br><span class="line">    │   ├── clusterinfo</span><br><span class="line">    │   ├── dirlock</span><br><span class="line">    │   ├── http_api</span><br><span class="line">    │   ├── lg</span><br><span class="line">    │   ├── pqueue</span><br><span class="line">    │   ├── protocol</span><br><span class="line">    │   ├── quantile</span><br><span class="line">    │   ├── statsd</span><br><span class="line">    │   ├── stringy</span><br><span class="line">    │   ├── test</span><br><span class="line">    │   ├── util</span><br><span class="line">    │   ├── version</span><br><span class="line">    │   └── writers</span><br><span class="line">    ├── nsqadmin</span><br><span class="line">    │   ├── static</span><br><span class="line">    │   └── test</span><br><span class="line">    ├── nsqd</span><br><span class="line">    │   └── test</span><br><span class="line">    ├── nsqlookupd</span><br><span class="line">    └── vendor</span><br><span class="line">        ├── github.com</span><br><span class="line">        └── golang.org</span><br></pre></td></tr></table></figure>
<p>阅读源码，笔者梳理了nsqd中几个比较重要的类，绘制了UML图。当然这个图不够专业也不够全，这里只罗列了笔者认为比较重要的一些类，以及类中的成员变量和方法，但是对理解nsqd的整体架构还是有一定帮助的。其中最重要的类应该是NSQD，内部封装了TCP和HTTP服务，并且提供了几个比较重要的方法。在nsqd的生命周期中只会有一个NSQD的实例。因为这个类很重要，所以nsqd中其他几个比较重要的类都有一个成员变量指向这个NSQD的实例。看UML图可以发现，除了Message这个类，其余的类中都有一个成员变量ctx *context，而ctx中存的就是NSQD实例的指针变量。NSQD中还存有一个topicMap，顾名思义，其中存放的是topic名称和Topic实例的映射，这样NSQD就能很方便的管理各个topic。Topic和Channel类其实我们应该是比较清晰的，从消息数据的流动来看，topic中应该包含各个channel的信息，因为一个topic可以包含多个channel；当然channel中也应该包含多个client的信息，因为一个channel可以有多个消费者，在这里我们理解一个消费者就是一个TCP连接，在真实的场景中可能就是我们有一个多进程的消费服务，每个进程维持了一个TCP长连接。所以我们看到在Topic这个类中有一个变量是channelMap，它是一个字典，存储了channel名称和Channel实例的映射关系；在Channel类中有一个变量clients，这也是一个字典，存储了clientID和Consumer之间的映射。Consumer在这里面实际上是一个接口定义，由于clientV2实现了这个接口，所以channel中实际上存储的是clientID和clientV2实例的映射。</p>
<p><img algn="center" src="/img/nsqd.png"></p>
<h3 id="2-2-NSQD源码微观"><a href="#2-2-NSQD源码微观" class="headerlink" title="2.2 NSQD源码微观"></a>2.2 NSQD源码微观</h3><p>其实深入到源码之后笔者也不知道应该怎么写了，想了想还是站在使用者的角度来梳理可能会比较容易理解一些。作为使用者，我们最常用的肯定就是往nsq发送消息，然后消费消息，其实这也是nsqd的最主要功能。所以我们将源码微观分为以下几块进行梳理：nsqd启动，nsqd接收消息，nsqd发送消息。当然这不是nsqd的所有功能，但可以说是主要功能，我们将梳理nsqd在每个模块都做了什么事情，以及怎么做的。</p>
<h4 id="2-2-1-nsqd启动"><a href="#2-2-1-nsqd启动" class="headerlink" title="2.2.1 nsqd启动"></a>2.2.1 nsqd启动</h4><p>nsqd的启动代码之前已经提到，位置在nsq/apps/nsqd/nsqd.go#main。nsqd使用了go-svc包提供的服务让其能够在windows和linux以守护线程的方式运行，并且能做到优雅的启动和退出。main函数内部实现很简单，program内部封装NSQD类，然后使用svc让程序跑起来。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> program <span class="keyword">struct</span> &#123;</span><br><span class="line">	nsqd *nsqd.NSQD</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	prg := &amp;program&#123;&#125;</span><br><span class="line">	<span class="keyword">if</span> err := svc.Run(prg, syscall.SIGINT, syscall.SIGTERM); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们看nsqd启动都做了哪些事情，位置在nsq/apps/nsqd/nsqd.go#Start。我把源码精简一下，如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *program)</span> <span class="title">Start</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	opts := nsqd.NewOptions()</span><br><span class="line"></span><br><span class="line">	flagSet := nsqdFlagSet(opts)</span><br><span class="line">	flagSet.Parse(os.Args[<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> cfg config</span><br><span class="line">	configFile := flagSet.Lookup(<span class="string">"config"</span>).Value.String()</span><br><span class="line">	cfg.Validate()</span><br><span class="line"></span><br><span class="line">	options.Resolve(opts, flagSet, cfg)</span><br><span class="line">	nsqd := nsqd.New(opts)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 加载元数据</span></span><br><span class="line">	err := nsqd.LoadMetadata()</span><br><span class="line">	<span class="comment">// 重新持久化元数据</span></span><br><span class="line">	err = nsqd.PersistMetadata()</span><br><span class="line">	<span class="comment">// 启动nsqd</span></span><br><span class="line">	nsqd.Main()</span><br><span class="line"></span><br><span class="line">	p.nsqd = nsqd</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>nsqd启动主要做了如下几个事情：加载配置，初始化NSQD实例，加载nsqd元数据，重新持久化nsqd元数据到磁盘，启动NSQD实例。在退出nsqd服务时，nsqd会将当时的topic，channel信息持久化到磁盘，其中包含所有topic和各个topic的包含的channel以及是否被暂停的信息，以便在下次启动时可以重新加载这些信息。这些信息以json文本的形式存储在磁盘中，如下是一个包含两个topic(test， name)，其中一个topic包含一个channel（test_channel)的元数据信息。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"topics"</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"channels"</span>:[</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"name"</span>:<span class="string">"test_channel"</span>,</span><br><span class="line">                    <span class="attr">"paused"</span>:<span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"name"</span>:<span class="string">"test"</span>,</span><br><span class="line">            <span class="attr">"paused"</span>:<span class="literal">false</span>&#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"channels"</span>:[],</span><br><span class="line">         	<span class="attr">"name"</span>:<span class="string">"name"</span>,</span><br><span class="line">            <span class="attr">"paused"</span>:<span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"version"</span>:<span class="string">"1.0.0-alpha"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以在我们启动nsqd时，它会先加载一次元数据，文件名为nsqd.dat。加载完元数据之后，nsqd还会立马再重新生成一份新的元数据覆盖原来的文件。这么做的目的是为了确保在nsqd重启时，还能正确的将当时的数据持久化到磁盘。<strong>为了安全的重写元数据，nsqd的做法并不是直接去写原始的文件，而是先写入一个tmp文件，然后重命名这个文件来覆盖原始文件</strong>。另外，在存放nsqd.dat文件相同的目录中，还有另外一个文件,比如nsqd.686.dat。这个文件的内容在不出意外的情况下，与nsqd.dat是一模一样的。在windows中，nsqd.686.dat也是一个文件，而在linux中则是一个软链，软链至nsqd.dat。接下来看一下最重要的nsqd.Main()做了哪些事情，同样把Main精简一下，如下。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *NSQD)</span> <span class="title">Main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> httpListener net.Listener</span><br><span class="line">	<span class="keyword">var</span> httpsListener net.Listener</span><br><span class="line"></span><br><span class="line">	ctx := &amp;context&#123;n&#125;</span><br><span class="line"></span><br><span class="line">	tcpListener, err := net.Listen(<span class="string">"tcp"</span>, n.getOpts().TCPAddress)</span><br><span class="line">	</span><br><span class="line">	n.tcpListener = tcpListener</span><br><span class="line">	tcpServer := &amp;tcpServer&#123;ctx: ctx&#125;</span><br><span class="line">	<span class="comment">// tcp服务</span></span><br><span class="line">	n.waitGroup.Wrap(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		protocol.TCPServer(n.tcpListener, tcpServer, n.logf)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	httpListener, err = net.Listen(<span class="string">"tcp"</span>, n.getOpts().HTTPAddress)</span><br><span class="line">	</span><br><span class="line">	n.httpListener = httpListener</span><br><span class="line">	httpServer := newHTTPServer(ctx, <span class="literal">false</span>, n.getOpts().TLSRequired == TLSRequired)</span><br><span class="line">	<span class="comment">// http服务</span></span><br><span class="line">	n.waitGroup.Wrap(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		http_api.Serve(n.httpListener, httpServer, <span class="string">"HTTP"</span>, n.logf)</span><br><span class="line">	&#125;)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 队列监控服务</span></span><br><span class="line">	n.waitGroup.Wrap(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; n.queueScanLoop() &#125;)</span><br><span class="line">	<span class="comment">// 网络拓扑发现服务</span></span><br><span class="line">	n.waitGroup.Wrap(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; n.lookupLoop() &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码其实已经很清晰了，Main中其实主要做了以下几件事：启动tcp服务，启动http服务，启动队列监控，启动网络拓扑发现。根据配置，Main中还有可能启动https服务（nsqd支持https）和统计监控服务，在这里我们只关心前面的四个服务，这四个服务都被n.waitGroup.Wrap包裹起来。这个Wrap函数的作用，其实是启动一个单独的goroutine来运行包裹起来的函数，所以，nsqd的这四个服务都分别运行在不同的goroutine中。Wrap中用了sync.WaitGroup来阻塞主线程，直到所有goroutine执行完成。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WaitGroupWrapper <span class="keyword">struct</span> &#123;</span><br><span class="line">	sync.WaitGroup</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *WaitGroupWrapper)</span> <span class="title">Wrap</span><span class="params">(cb <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">	w.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		cb()</span><br><span class="line">		w.Done()</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>http服务其实跟大多数web后端一样，定义了router和handler之间的关系，结构清晰，位置在nsq/nsqd/http.go#newHTTPServer，这里就不展开说了。tcp服务由于不存在路由接口的概念，因此在<a href="https://nsq.io/clients/tcp_protocol_spec.html" target="_blank" rel="noopener">官方文档TCP PROTOCOL SPEC</a>中已经把服务器和客户端之间传递的字节码消息格式定义好了。之前我们已经大致看过http提供有哪些服务，其中没有一个接口能让客户端获取到消息，而实际上客户端消费nsq消息是通过tcp服务，并且是由<strong>nsqd主动推送到客户端而不是客户端主动获取</strong>。nsqd不提供http api方式的获取消息，笔者个人认为主要是因为http是无状态无连接的，如果消息获取走http方式，不仅效率不高，也不利于nsqd实现可靠的服务。nsqd为了提供一个高可用高可靠的服务，它实现了数据流控制和心跳机制。数据流控制可以理解为客户端告诉nsqd服务端当前可以处理的最大消息数，避免nsqd推送大量消息，实现方式主要就是客户端向服务器更新其RDY状态值。比如初次连接时，客户端的RDY设置为0，表示还没准备好接收数据，当客户端准备好了之后，可以向服务器发送命令更新RDY至某个值，比如说100，服务器则直接将100条消息推送至客户端。心跳机制则要求客户端定时回复nsqd服务端发送的心跳消息。以上两点实际上要求nsqd服务端和客户端之间必须维护一个有状态的长连接来保证服务可靠性，综合来说使用tcp比较合适。为了了解nsqd的tcp服务是如何实现的，我们把相关代码粘贴如下，同样是做过精简的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TCPHandler <span class="keyword">interface</span> &#123;</span><br><span class="line">	Handle(net.Conn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TCPServer</span><span class="params">(listener net.Listener, handler TCPHandler, logf lg.AppLogFunc)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		clientConn, err := listener.Accept()</span><br><span class="line">		<span class="keyword">go</span> handler.Handle(clientConn)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TCPServer的第二个参数接收一个TCPHandler类型的对象，然后在监听到连接之后，启动一个goroutine调用handler.Handle来处理这个连接。TCPHandler是一个接口定义，内部只有一个函数Handle，所以任何实现了Handle方法的类都可以作为TCPServer的第二个参数。如Main中实现的，在调用TCPServer时，nsqd将tcpServer作为TCPServer的第二个参数，因此我们知道，tcpServer必然实现了Handle方法，我们看看Handle中都做了哪些事情。客户端在连接到nsqd时，需要携带协议版本信息完成初始化工作，初始化主要是生成一个protocolV2对象，然后将连接对象作为参数传递近IOLoop中，最后在IOLoop中对tcp连接进行处理。只有当客户端发起tcp连接时，nsqd才会单独启一个goroutine来处理此连接，所以关于tcp连接的处理逻辑放在介绍消息发送和消息接收时在详细展开。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> tcpServer <span class="keyword">struct</span> &#123;</span><br><span class="line">	ctx *context</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *tcpServer)</span> <span class="title">Handle</span><span class="params">(clientConn net.Conn)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4</span>)</span><br><span class="line">	_, err := io.ReadFull(clientConn, buf)</span><br><span class="line">	protocolMagic := <span class="keyword">string</span>(buf)</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">var</span> prot protocol.Protocol</span><br><span class="line">	<span class="keyword">switch</span> protocolMagic &#123;</span><br><span class="line">	<span class="comment">// 新建的连接需要指定协议的版本来完成初始化</span></span><br><span class="line">	<span class="keyword">case</span> <span class="string">"  V2"</span>:</span><br><span class="line">		prot = &amp;protocolV2&#123;ctx: p.ctx&#125;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		protocol.SendFramedResponse(clientConn, frameTypeError, []<span class="keyword">byte</span>(<span class="string">"E_BAD_PROTOCOL"</span>))</span><br><span class="line">		clientConn.Close()</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 每个连接对应一个Protocol对象</span></span><br><span class="line">	err = prot.IOLoop(clientConn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，我们分析一下queueScanLoop。queueScanLoop主要用于处理各个channel的inFlight队列和Deferred队列，是nsqd中一个比较重要的函数。每个channel都维护了inFlight和Deferred两个队列。<strong>其中inFlight队列存放了已经投递出去，但是还没有被客户端确认的消息，Deferred队列则存放了延迟投递的消息。</strong>nsqd将消息主动推送给某个客户端之后，会将这个消息移到inFlight队列，直到客户端处理完这个消息，并告知nsqd服务器可以结束这个消息（finish），此时nsqd会将此消息从inFlight队列删除。除了finish之外，nsqd还支持其他的操作，比如重新排队（requeue）。如果消息投递到客户端之后，过了很久还没收到确认，queueScanLoop负责将此消息重新投递。这样做的好处是即使因为网络原因导致消息没有投递成功，nsqd也能保证此消息再次投递（requeue），换句话说每个消息至少会被投递一次。当然， 从这个策略来说，nsq消息队列不是有序的。如果是强依赖消息顺序的业务，不应该使用nsq。Deferred队列用于存放延迟发送的消息，即我们可以指定一个消息在多久之后投递出去，一旦queueScanLoop发现某个延迟发送的消息可被投递时，会将其从Deferred队列移除并且再投递给某个客户端之后添加到inFlight队列。</p>
<p>queueScanLoop实现了类似redis的<code>概率失效算法(probabilistic expiration algorithm)</code>: 每隔QueueScanInterval秒（默认100)从nsqd包含的所有channel中随机选择QueueScanSelectionCount个（默认20）进行处理。如果在选择的QueueScanSelectionCount个channel中超过QueueScanDirtyPercent（默认25%）的channel需要处理inFlight或者Deferred队列，则在处理完这些channel之后，继续选择QueueScanSelectionCount个channel处理它们的inFlight和Deferred队列，直到不足QueueScanDirtyPercent，queueScanLoop会停下来，等待下一个QueueScanInterval时间的到来。在queueScanLoop内部维护了一个goroutine池子，我们称之为queueScanWorker pool，每个queueScanWorker是一个goroutine，这些worker的工作就是之前提到的用于实际处理每个channel的inFlight和Deferred队列。queueScanWorker pool内部worker数量是随着channel数量动态调整的，范围是1 &lt;= pool &lt;= min(num*0.25, QueueScanWorkerPoolMax)，每隔QueueScanRefreshInterval秒（默认5）就会动态调整一次pool中worker的数量。接下来我们看一下源码，queueScanLoop是如何优雅的实现概率失效算法，以及如何优雅的实现worker数量的动态调整。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *NSQD)</span> <span class="title">queueScanLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line">	workCh := <span class="built_in">make</span>(<span class="keyword">chan</span> *Channel, n.getOpts().QueueScanSelectionCount)</span><br><span class="line">	responseCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, n.getOpts().QueueScanSelectionCount)</span><br><span class="line">	<span class="comment">// 用于动态关闭worker的golang channel</span></span><br><span class="line">	closeCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">	workTicker := time.NewTicker(n.getOpts().QueueScanInterval)</span><br><span class="line">	refreshTicker := time.NewTicker(n.getOpts().QueueScanRefreshInterval)</span><br><span class="line"></span><br><span class="line">	channels := n.channels()</span><br><span class="line">	<span class="comment">// 进入for循环之前，先调整一次worker数量</span></span><br><span class="line">	n.resizePool(<span class="built_in">len</span>(channels), workCh, responseCh, closeCh)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="comment">// 每隔QueueScanInterval秒，随机选择QueueScanSelectionCount个channel进行处理</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-workTicker.C:</span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(channels) == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">		<span class="comment">// 每隔QueueScanRefreshInterval秒重新调整一次worker数量</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-refreshTicker.C:</span><br><span class="line">			channels = n.channels()</span><br><span class="line">			n.resizePool(<span class="built_in">len</span>(channels), workCh, responseCh, closeCh)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-n.exitChan:</span><br><span class="line">			<span class="comment">// 收到退出信号，跳到退出代码</span></span><br><span class="line">			<span class="keyword">goto</span> exit</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		num := n.getOpts().QueueScanSelectionCount</span><br><span class="line">		<span class="keyword">if</span> num &gt; <span class="built_in">len</span>(channels) &#123;</span><br><span class="line">			num = <span class="built_in">len</span>(channels)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	loop:</span><br><span class="line">		<span class="comment">// 从所有channel中随机选择QueueScanSelectionCount个进行处理</span></span><br><span class="line">		<span class="keyword">for</span> _, i := <span class="keyword">range</span> util.UniqRands(num, <span class="built_in">len</span>(channels)) &#123;</span><br><span class="line">			workCh &lt;- channels[i]</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		numDirty := <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; num; i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> &lt;-responseCh &#123;</span><br><span class="line">				<span class="comment">// 如果某个channel的inFlight或者Deferred</span></span><br><span class="line">				<span class="comment">// 队列存在超时或者到期的消息，则标记一次</span></span><br><span class="line">				numDirty++</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 如果超过QueueScanDirtyPercent的channel被标记为需要处理，</span></span><br><span class="line">		<span class="comment">// 则继续选择QueueScanSelectionCount个channel重复上述步骤</span></span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">float64</span>(numDirty)/<span class="keyword">float64</span>(num) &gt; n.getOpts().QueueScanDirtyPercent &#123;</span><br><span class="line">			<span class="keyword">goto</span> loop</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">exit:</span><br><span class="line">	n.logf(LOG_INFO, <span class="string">"QUEUESCAN: closing"</span>)</span><br><span class="line">	<span class="built_in">close</span>(closeCh)</span><br><span class="line">	workTicker.Stop()</span><br><span class="line">	refreshTicker.Stop()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调整worker数量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *NSQD)</span> <span class="title">resizePool</span><span class="params">(num <span class="keyword">int</span>, workCh <span class="keyword">chan</span> *Channel, responseCh <span class="keyword">chan</span> <span class="keyword">bool</span>, closeCh <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 理想状态下的worker数量为channel总量的25%。</span></span><br><span class="line">	<span class="comment">// worker数量满足1 &lt;= pool &lt;= min(num * 0.25, QueueScanWorkerPoolMax)</span></span><br><span class="line">	idealPoolSize := <span class="keyword">int</span>(<span class="keyword">float64</span>(num) * <span class="number">0.25</span>)</span><br><span class="line">	<span class="keyword">if</span> idealPoolSize &lt; <span class="number">1</span> &#123;</span><br><span class="line">		idealPoolSize = <span class="number">1</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> idealPoolSize &gt; n.getOpts().QueueScanWorkerPoolMax &#123;</span><br><span class="line">		idealPoolSize = n.getOpts().QueueScanWorkerPoolMax</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 当前worker数量符合要求</span></span><br><span class="line">		<span class="keyword">if</span> idealPoolSize == n.poolSize &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> idealPoolSize &lt; n.poolSize &#123;</span><br><span class="line">			<span class="comment">// 当前worker数量过多，需要关闭一个worker</span></span><br><span class="line">			<span class="comment">// 往closeCh管道中发送一个消息，监听到这个消息的worker将退出</span></span><br><span class="line">			closeCh &lt;- <span class="number">1</span></span><br><span class="line">			n.poolSize--</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 当前worker数量过少，需要增加一个worker</span></span><br><span class="line">			n.waitGroup.Wrap(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				n.queueScanWorker(workCh, responseCh, closeCh)</span><br><span class="line">			&#125;)</span><br><span class="line">			n.poolSize++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *NSQD)</span> <span class="title">queueScanWorker</span><span class="params">(workCh <span class="keyword">chan</span> *Channel, responseCh <span class="keyword">chan</span> <span class="keyword">bool</span>, closeCh <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="comment">// 获取到在queueScanLoop中随机选择的一个channel</span></span><br><span class="line">		<span class="keyword">case</span> c := &lt;-workCh:</span><br><span class="line">			now := time.Now().UnixNano()</span><br><span class="line">			dirty := <span class="literal">false</span></span><br><span class="line">			<span class="comment">// 扫描inFlight队列，将已过期消息移除，</span></span><br><span class="line">			<span class="comment">// 并且重新添加到channel中，等待重新推送到客户端</span></span><br><span class="line">			<span class="keyword">if</span> c.processInFlightQueue(now) &#123;</span><br><span class="line">				dirty = <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 扫描Deferred队列，将已到期消息移除，</span></span><br><span class="line">			<span class="comment">// 并且重新添加到channel中，等待重新推送到客户端</span></span><br><span class="line">			<span class="keyword">if</span> c.processDeferredQueue(now) &#123;</span><br><span class="line">				dirty = <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 通知queueScanLoop该channel存在需要处理的消息</span></span><br><span class="line">			responseCh &lt;- dirty</span><br><span class="line">		<span class="keyword">case</span> &lt;-closeCh:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>queueScanLoop内部维护三个通道，用于动态调整worker数量以及与worker之间进行通信。分别是带缓存的workCh和responseCh，以及不带缓存的closeCh。queueScanLoop将随机选择的channel放入workCh中，任何一个worker在监听到workCh有消息时拿到一个channel进行处理，处理的结果通过responseCh返回给queueScanLoop，以便queueScanLoop决策是否要继续循环处理剩余的channel。为了实现动态调整worker数量，所有worker都会监听closeCh，当worker数量过多时，queueScanLoop往closeCh中发送一个退出消息，任何一个worker在监听到退出消息时结束退出；当worker数量过少时，则启动一个新的worker。</p>
<p>概率失效算法的策略可能会导致inFlight队列中已过期的消息或者Deferred队列中已经到期的消息没有被及时投递。因为inFlight中的消息实际上已经被至少投递过一次，它的存在主要是为了应对消息投递失败和消息处理超时的情况，所以没有被及时重新投递问题不大。但是，deferred队列中延迟发送的消息可能会比用户预期的时间更长。如果是对延迟发送的时间有严格要求的应用场景，笔者认为不应该强依赖nsq的deferred功能。当然，通过调整配置我们能够减少概率失效算法的副作用，为此我们可以选择改变以下某个配置或者多个并行：减小QueueScanInterval的值让worker工作的更加频繁，加大QueueScanSelectionCount的值让queueScanLoop每次随机选择的channel更多，减小QueueScanDirtyPercent的值让worker一直循环直到需要处理的channel数量占总量的比例低于这个值。</p>
<h4 id="2-2-2-nsqd接收消息"><a href="#2-2-2-nsqd接收消息" class="headerlink" title="2.2.2 nsqd接收消息"></a>2.2.2 nsqd接收消息</h4><p>nsqd提供了tcp和http两种方式来接收客户端发送的消息，向nsqd发送消息的客户端这里称之为消息生产者。以下我们将分别介绍一下nsqd在接收消息时，http和tcp的方式分别是如何实现的。</p>
<h5 id="2-2-2-1-HTTP方式接收消息"><a href="#2-2-2-1-HTTP方式接收消息" class="headerlink" title="2.2.2.1 HTTP方式接收消息"></a>2.2.2.1 HTTP方式接收消息</h5><p>我们知道HTTP是基于TCP/IP，具有无连接无状态等特点的通信协议。这里说的无连接并不是真的指客户端与服务器之间不建立连接，而是说二者每次连接只处理一个请求。nsqd提供了HTTP的方式来支持接收消息，这意味着客户端在需要异步处理时，将消息体格式化之后请求一次nsqd服务器即可完成消息的发送。在笔者接触的大部分应用场景中，客户端往nsqd发送消息主要也是通过http方式。因为大部分的异步处理场景是穿插在我们的业务流程中的。前面我们说过，nsqd在启动时，会启动一个http服务。接下来我们看一下nsqd是如何使用http服务来接收消息的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在Main中启动http服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *NSQD)</span> <span class="title">Main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ...  </span><br><span class="line">    httpServer := newHTTPServer(ctx, <span class="literal">false</span>, n.getOpts().TLSRequired == TLSRequired)</span><br><span class="line">	n.waitGroup.Wrap(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		http_api.Serve(n.httpListener, httpServer, <span class="string">"HTTP"</span>, n.logf)</span><br><span class="line">	&#125;)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置http服务的路由以及handler</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newHTTPServer</span><span class="params">(ctx *context, tlsEnabled <span class="keyword">bool</span>, tlsRequired <span class="keyword">bool</span>)</span> *<span class="title">httpServer</span></span> &#123;</span><br><span class="line">	router := httprouter.New()</span><br><span class="line">	...</span><br><span class="line">    </span><br><span class="line">	s := &amp;httpServer&#123;</span><br><span class="line">		ctx:         ctx,</span><br><span class="line">		tlsEnabled:  tlsEnabled,</span><br><span class="line">		tlsRequired: tlsRequired,</span><br><span class="line">		router:      router,</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 配置路由以及handler</span></span><br><span class="line">	router.Handle(<span class="string">"POST"</span>, <span class="string">"/pub"</span>, http_api.Decorate(s.doPUB, http_api.V1))</span><br><span class="line">	router.Handle(<span class="string">"POST"</span>, <span class="string">"/mpub"</span>, http_api.Decorate(s.doMPUB, http_api.V1))</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// http接收消息handler</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *httpServer)</span> <span class="title">doPUB</span><span class="params">(w http.ResponseWriter, req *http.Request, ps httprouter.Params)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">    </span><br><span class="line">	readMax := s.ctx.nsqd.getOpts().MaxMsgSize + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从请求中获取消息体</span></span><br><span class="line">	body, err := ioutil.ReadAll(io.LimitReader(req.Body, readMax))</span><br><span class="line">	</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从请求中解析出topic name，然后根据topic name从nsqd实例中获取topic实例。</span></span><br><span class="line">	<span class="comment">// 如果还没有此topic则新建一个。</span></span><br><span class="line">	reqParams, topic, err := s.getTopicFromQuery(req)</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">var</span> deferred time.Duration</span><br><span class="line">	<span class="comment">// 请求中可以带上defer参数，表示消息可以延迟多长时间再投递出去</span></span><br><span class="line">	<span class="keyword">if</span> ds, ok := reqParams[<span class="string">"defer"</span>]; ok &#123;</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">var</span> di <span class="keyword">int64</span></span><br><span class="line">		di, err = strconv.ParseInt(ds[<span class="number">0</span>], <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">		deferred = time.Duration(di) * time.Millisecond</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 生成一个唯一id构建Message对象</span></span><br><span class="line">	msg := NewMessage(topic.GenerateID(), body)</span><br><span class="line">	msg.deferred = deferred</span><br><span class="line">	<span class="comment">// 将消息加入topic中</span></span><br><span class="line">	err = topic.PutMessage(msg)</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">return</span> <span class="string">"OK"</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 往topic中投递消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Topic)</span> <span class="title">PutMessage</span><span class="params">(m *Message)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	t.RLock()</span><br><span class="line">	<span class="keyword">defer</span> t.RUnlock()</span><br><span class="line">	<span class="comment">// 判断此topic是否正处于关闭或者删除状态</span></span><br><span class="line">	<span class="comment">// 此状态可能维持的时间比较长，因为如果是关闭topic的话</span></span><br><span class="line">	<span class="comment">// nsqd需要将topic还在内存中的消息持久化到磁盘</span></span><br><span class="line">	<span class="keyword">if</span> atomic.LoadInt32(&amp;t.exitFlag) == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">"exiting"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将消息放入topic</span></span><br><span class="line">	err := t.put(m)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 增加topic中消息的个数，原子操作</span></span><br><span class="line">	atomic.AddUint64(&amp;t.messageCount, <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// topic存放消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Topic)</span> <span class="title">put</span><span class="params">(m *Message)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="comment">// 将消息存入topic的内存队列</span></span><br><span class="line">	<span class="keyword">case</span> t.memoryMsgChan &lt;- m:</span><br><span class="line">	<span class="comment">// 如果内存队列已满，则写入磁盘队列</span></span><br><span class="line">	<span class="comment">// nsq内部实现了一个基于文件的FIFO队列</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		b := bufferPoolGet()</span><br><span class="line">		err := writeMessageToBackend(b, m, t.backend)</span><br><span class="line">		bufferPoolPut(b)</span><br><span class="line">		t.ctx.nsqd.SetHealth(err)</span><br><span class="line">        ...</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总的来说，nsqd接收消息的流程是从客户端的request中解析出topic name，以及消息体数据，然后获取topic实例，<strong>如果还没有此topic则新建一个</strong>，最后将消息存入topic中。nsq的每一个topic都有两个队列，分别是<code>内存队列(memoryMsgChan)</code>和<code>磁盘队列(backend)</code>都是用于存放消息。topic在接收到一个消息时，首先会尝试将消息存入内存队列中。由于golang的语言特性，它的带缓冲channel天然适合作为内存队列。nsqd的默认配置中，memoryMsgChan的长度默认是10000。如果memoryMsgChan已经满了，则将消息存入backend。backend是一个基于文件的FIFO队列，过多的消息数据会以文件形式存储在磁盘中。<strong>nsqd在运行过程中如果关闭了某个topic，在退出的流程中topic会将memoryMsgChan的数据先存入backend中。backend的存在保证了数据的持久性。</strong></p>
<p>前面说过，客户端在往某个topic发送消息时，nsqd会先从自己的topicMap中获取此topic实例，如果不存在则新建一个。获取topic实例的这段代码是线程安全的，值得我们学习，如下。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *NSQD)</span> <span class="title">GetTopic</span><span class="params">(topicName <span class="keyword">string</span>)</span> *<span class="title">Topic</span></span> &#123;</span><br><span class="line">	<span class="comment">// 加读锁，不限制读但是限制写</span></span><br><span class="line">	n.RLock()</span><br><span class="line">	<span class="comment">// 从nsqd的topicMap中获取topic实例，如果存在直接返回</span></span><br><span class="line">	t, ok := n.topicMap[topicName]</span><br><span class="line">	n.RUnlock()</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		<span class="keyword">return</span> t</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 不存在此topic实例，这里加个写锁，保证后面的创建操作是线程安全的</span></span><br><span class="line">	n.Lock()</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 再次从topicMap中获取一次。为什么？</span></span><br><span class="line">	<span class="comment">// 考虑一种情况：在某一时刻，同时有线程A B C获取同一个topic D.</span></span><br><span class="line">	<span class="comment">// 此时A B C通过n.topicMap[D]没拿到实例，全部走到n.Lock()，</span></span><br><span class="line">	<span class="comment">// A先拿到锁成功创建了D的实例并且添加入topicMap中，然后释放锁返回。</span></span><br><span class="line">	<span class="comment">// B, C中某一个获取到A释放的锁进入临界区，</span></span><br><span class="line">	<span class="comment">// 如果没有再从topicMap中获取一次，则会重新创建一个topic实例，</span></span><br><span class="line">	<span class="comment">// 可能会造成数据丢失</span></span><br><span class="line">	t, ok = n.topicMap[topicName]</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		<span class="comment">// 如果此时获取到topic实例</span></span><br><span class="line">		<span class="comment">// 说明几乎在同一时刻有另外一个线程也在获取该topic</span></span><br><span class="line">		n.Unlock()</span><br><span class="line">		<span class="keyword">return</span> t</span><br><span class="line">	&#125;</span><br><span class="line">	deleteCallback := <span class="function"><span class="keyword">func</span><span class="params">(t *Topic)</span></span> &#123;</span><br><span class="line">		n.DeleteExistingTopic(t.name)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 第二次没有从topicMap中获取到，</span></span><br><span class="line">	<span class="comment">// 则新建topic实例，并添加到topicMap中</span></span><br><span class="line">	t = NewTopic(topicName, &amp;context&#123;n&#125;, deleteCallback)</span><br><span class="line">	n.topicMap[topicName] = t</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 到这里已经完成了topic实例的新建工作</span></span><br><span class="line">	<span class="comment">// 为了提高性能做了一个锁替换操作，</span></span><br><span class="line">	<span class="comment">// 将nsqd维度的锁替换成topic维度的锁。</span></span><br><span class="line">	<span class="comment">// 替换的顺序是先加topic维度的写锁，然后释放nsqd维度的写锁</span></span><br><span class="line">	t.Lock()</span><br><span class="line">	n.Unlock()</span><br><span class="line">  </span><br><span class="line">	...</span><br><span class="line">	t.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 发送消息通知messagePump状态发生变更</span></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> t.channelUpdateChan &lt;- <span class="number">1</span>:</span><br><span class="line">	<span class="keyword">case</span> &lt;-t.exitChan:</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-2-2-2-TCP方式接收消息"><a href="#2-2-2-2-TCP方式接收消息" class="headerlink" title="2.2.2.2 TCP方式接收消息"></a>2.2.2.2 TCP方式接收消息</h5><p>总的来说TCP接收消息和HTTP接收消息方式除了使用的协议不同，在本质上是一样的。但是为了对TCP处理流程有一个大致的了解，我们还是深入源码看一下从TCP服务启动，到最终接收消息nsqd是怎么处理的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nsqd启动</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *NSQD)</span> <span class="title">Main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	</span><br><span class="line">	ctx := &amp;context&#123;n&#125;</span><br><span class="line"></span><br><span class="line">	tcpListener, err := net.Listen(<span class="string">"tcp"</span>, n.getOpts().TCPAddress)</span><br><span class="line"></span><br><span class="line">	n.Lock()</span><br><span class="line">	n.tcpListener = tcpListener</span><br><span class="line">	n.Unlock()</span><br><span class="line">    </span><br><span class="line">	tcpServer := &amp;tcpServer&#123;ctx: ctx&#125;</span><br><span class="line">	<span class="comment">// nsqd启动时会在一个单独的goroutine中启动tcp服务</span></span><br><span class="line">	n.waitGroup.Wrap(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		protocol.TCPServer(n.tcpListener, tcpServer, n.logf)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// tcp handler</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *tcpServer)</span> <span class="title">Handle</span><span class="params">(clientConn net.Conn)</span></span> &#123;</span><br><span class="line">	</span><br><span class="line">	buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4</span>)</span><br><span class="line">	_, err := io.ReadFull(clientConn, buf)</span><br><span class="line">	protocolMagic := <span class="keyword">string</span>(buf)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> prot protocol.Protocol</span><br><span class="line">	<span class="keyword">switch</span> protocolMagic &#123;</span><br><span class="line">	<span class="comment">// 客户端与nsqd的tcp服务连接之后，需要在body中指定协议版本</span></span><br><span class="line">	<span class="keyword">case</span> <span class="string">"  V2"</span>:</span><br><span class="line">		prot = &amp;protocolV2&#123;ctx: p.ctx&#125;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		protocol.SendFramedResponse(clientConn, frameTypeError, []<span class="keyword">byte</span>(<span class="string">"E_BAD_PROTOCOL"</span>))</span><br><span class="line">		clientConn.Close()</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 连接建立，在IOLoop中进行通信</span></span><br><span class="line">	err = prot.IOLoop(clientConn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *protocolV2)</span> <span class="title">IOLoop</span><span class="params">(conn net.Conn)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	<span class="keyword">var</span> line []<span class="keyword">byte</span></span><br><span class="line">	<span class="keyword">var</span> zeroTime time.Time</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 为每个连接生成一个clientID</span></span><br><span class="line">	clientID := atomic.AddInt64(&amp;p.ctx.nsqd.clientIDSequence, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 使用生成的ClientID创建一个client对象</span></span><br><span class="line">	client := newClientV2(clientID, conn, p.ctx)</span><br><span class="line">	</span><br><span class="line">	messagePumpStartedChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">    <span class="comment">// 为每个连接启动一个goroutine，通过golang channel进行消息通信</span></span><br><span class="line">    <span class="comment">// 完成消息接收，消息投递，订阅channel，发送心跳包等工作</span></span><br><span class="line">	<span class="keyword">go</span> p.messagePump(client, messagePumpStartedChan)</span><br><span class="line">    <span class="comment">// messagePumpStartedChan作为messagePump的参数</span></span><br><span class="line">    <span class="comment">// 用来阻塞当前进程，直到messagePump完成初始化工作，</span></span><br><span class="line">    <span class="comment">// 关闭messagePumpStartedChan后，当前进程才能继续</span></span><br><span class="line">	&lt;-messagePumpStartedChan</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		...</span><br><span class="line">        <span class="comment">// 读取直到第一次遇到'\n'，</span></span><br><span class="line">        <span class="comment">// 返回缓冲里的包含已读取的数据和'\n'字节的切片</span></span><br><span class="line">		line, err = client.Reader.ReadSlice(<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// trim the '\n'</span></span><br><span class="line">		line = line[:<span class="built_in">len</span>(line)<span class="number">-1</span>]</span><br><span class="line">		<span class="comment">// optionally trim the '\r'</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(line) &gt; <span class="number">0</span> &amp;&amp; line[<span class="built_in">len</span>(line)<span class="number">-1</span>] == <span class="string">'\r'</span> &#123;</span><br><span class="line">			line = line[:<span class="built_in">len</span>(line)<span class="number">-1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 从数据中解析出命令</span></span><br><span class="line">		params := bytes.Split(line, separatorBytes)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> response []<span class="keyword">byte</span></span><br><span class="line">        <span class="comment">// 执行命令</span></span><br><span class="line">		response, err = p.Exec(client, params)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> response != <span class="literal">nil</span> &#123;</span><br><span class="line">			err = p.Send(client, frameTypeResponse, response)</span><br><span class="line">		&#125;</span><br><span class="line">        ...</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 如果在上面的for中出现error，则退出循环</span></span><br><span class="line">	conn.Close()</span><br><span class="line">	<span class="built_in">close</span>(client.ExitChan)</span><br><span class="line">	<span class="keyword">if</span> client.Channel != <span class="literal">nil</span> &#123;</span><br><span class="line">		client.Channel.RemoveClient(client.ID)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tcp命令执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *protocolV2)</span> <span class="title">Exec</span><span class="params">(client *clientV2, params [][]<span class="keyword">byte</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> bytes.Equal(params[<span class="number">0</span>], []<span class="keyword">byte</span>(<span class="string">"IDENTIFY"</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span> p.IDENTIFY(client, params)</span><br><span class="line">	&#125;</span><br><span class="line">	err := enforceTLSPolicy(client, p, params[<span class="number">0</span>])</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> bytes.Equal(params[<span class="number">0</span>], []<span class="keyword">byte</span>(<span class="string">"FIN"</span>)):</span><br><span class="line">		<span class="keyword">return</span> p.FIN(client, params)</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">case</span> bytes.Equal(params[<span class="number">0</span>], []<span class="keyword">byte</span>(<span class="string">"PUB"</span>)):</span><br><span class="line">		<span class="keyword">return</span> p.PUB(client, params)</span><br><span class="line">	<span class="keyword">case</span> bytes.Equal(params[<span class="number">0</span>], []<span class="keyword">byte</span>(<span class="string">"MPUB"</span>)):</span><br><span class="line">		<span class="keyword">return</span> p.MPUB(client, params)</span><br><span class="line">	...</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, protocol.NewFatalClientErr(<span class="literal">nil</span>, <span class="string">"E_INVALID"</span>, fmt.Sprintf(<span class="string">"invalid command %s"</span>, params[<span class="number">0</span>]))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *protocolV2)</span> <span class="title">PUB</span><span class="params">(client *clientV2, params [][]<span class="keyword">byte</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	<span class="comment">// 从TCP参数中解析出topic name</span></span><br><span class="line">	topicName := <span class="keyword">string</span>(params[<span class="number">1</span>])</span><br><span class="line">	</span><br><span class="line">	bodyLen, err := readLen(client.Reader, client.lenSlice)</span><br><span class="line">	messageBody := <span class="built_in">make</span>([]<span class="keyword">byte</span>, bodyLen)</span><br><span class="line">	_, err = io.ReadFull(client.Reader, messageBody)</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 与http接收消息一样，获取topic实例之后，存入一条消息</span></span><br><span class="line">	topic := p.ctx.nsqd.GetTopic(topicName)</span><br><span class="line">	msg := NewMessage(topic.GenerateID(), messageBody)</span><br><span class="line">	err = topic.PutMessage(msg)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> okBytes, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是nsqd使用tcp方式接收消息的步骤。不难看出，http和tcp在本质上没有什么差别，都是先获取或者创建一个topic，然后用NewMessage构建一个消息对象，最后调用topic.PutMessage将消息存入topic中。</p>
<h4 id="2-2-3-nsqd发送消息"><a href="#2-2-3-nsqd发送消息" class="headerlink" title="2.2.3 nsqd发送消息"></a>2.2.3 nsqd发送消息</h4><p>之前说过nsqd往客户端投递消息走的是tcp方式，并且是在连接建立之后由nsqd服务器主动向客户端投递。因此我们可以写一个简单的消费脚本，负责打印从nsqd接受到的消息。nsqd官方提供了几种封装好的客户端代码，以下是用python实现的简单代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> nsq</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每次接收到消息就打印出来</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handler</span><span class="params">(message)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> message.body</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">r = nsq.Reader(</span><br><span class="line">    message_handler=handler,</span><br><span class="line">    nsqd_tcp_addresses=[<span class="string">'127.0.0.1:4150'</span>],</span><br><span class="line">    topic=<span class="string">'test'</span>, </span><br><span class="line">    channel=<span class="string">'test_channel'</span>, </span><br><span class="line">    lookupd_poll_interval=<span class="number">15</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">nsq.run()</span><br></pre></td></tr></table></figure>
<p>执行nsq.run之后，客户端就会与nsqd服务器建立连接。连接建立之后就会在tcpServer.Handle中为连接创建一个protocolV2对象，最后调用protocolV2.IOLoop进入循环。客户端发起连接之初，会依次向nsqd服务器发送以下3个命令：IDENTIFY，SUB，RDY。</p>
<ul>
<li><code>IDENTIFY</code>: 主要用于客户端与nsqd之间互相交换配置信息。当客户端初次连接时，在INDNTIFY命令的请求中会携带上json格式的配置信息，里面包含了客户端希望服务器使用的配置，比如HeartbeatInterval， OutputBufferSize。而nsqd根据请求中的配置修改本身的默认配置之后会将服务器端的重要配置返回给客户端，客户端拿到服务器的配置后可调整自身参数，比如：MaxMsgTimeout， MsgTimeout，MaxRdyCount。</li>
<li><code>SUB</code>: 告知nsqd，此连接订阅的是哪个topic和channel。</li>
<li><code>RDY</code>: 由于消息是从nsqd推送到客户端的，为了避免nsqd推送大量消息导致消费者来不及处理，客户端维护了一个RDY状态告知nsqd当前可以接受的消息数量。</li>
</ul>
<p>消费客户端连接入nsqd之后，nsqd服务端的log如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[nsqd] 2018/06/09 15:30:38.356354 DEBUG: PROTOCOL(V2): [127.0.0.1:64083] [IDENTIFY]</span><br><span class="line">[nsqd] 2018/06/09 15:30:38.356600 DEBUG: PROTOCOL(V2): [127.0.0.1:64083] &#123;ClientID:vivi Hostname:vivi.local HeartbeatInterval:30000 OutputBufferSize:16384 OutputBufferTimeout:250 FeatureNegotiation:true TLSv1:false Deflate:false DeflateLevel:6 Snappy:false SampleRate:0 UserAgent:pynsq/0.8.2 MsgTimeout:0&#125;</span><br><span class="line">[nsqd] 2018/06/09 15:30:38.356638 INFO: [127.0.0.1:64083] IDENTIFY: &#123;ClientID:vivi Hostname:vivi.local HeartbeatInterval:30000 OutputBufferSize:16384 OutputBufferTimeout:250 FeatureNegotiation:true TLSv1:false Deflate:false DeflateLevel:6 Snappy:false SampleRate:0 UserAgent:pynsq/0.8.2 MsgTimeout:0&#125;</span><br><span class="line">[nsqd] 2018/06/09 15:30:38.357431 DEBUG: PROTOCOL(V2): [127.0.0.1:64083] [SUB test test_channel]</span><br><span class="line">[nsqd] 2018/06/09 15:30:38.357631 DEBUG: PROTOCOL(V2): [127.0.0.1:64083] [RDY 1]</span><br></pre></td></tr></table></figure>
<p>protocolV2.IOLoop在前面已经介绍过了，每个新建立的连接在进入IOLoop之后会启动一个单独的goroutine跑messagePump，然后进入for循环，不断的接收客户端的命令，作为参数传入EXEC中执行。上述的三个命令也是通过EXEC调用对应的handle执行的。现在我们要详细介绍一下messagePump。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *protocolV2)</span> <span class="title">messagePump</span><span class="params">(client *clientV2, startedChan <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	<span class="keyword">var</span> memoryMsgChan <span class="keyword">chan</span> *Message</span><br><span class="line">	<span class="keyword">var</span> backendMsgChan <span class="keyword">chan</span> []<span class="keyword">byte</span></span><br><span class="line">	<span class="keyword">var</span> subChannel *Channel</span><br><span class="line">	<span class="keyword">var</span> flusherChan &lt;-<span class="keyword">chan</span> time.Time</span><br><span class="line">	<span class="keyword">var</span> sampleRate <span class="keyword">int32</span></span><br><span class="line"></span><br><span class="line">    subEventChan := client.SubEventChan</span><br><span class="line">	identifyEventChan := client.IdentifyEventChan</span><br><span class="line">	outputBufferTicker := time.NewTicker(client.OutputBufferTimeout)</span><br><span class="line">	heartbeatTicker := time.NewTicker(client.HeartbeatInterval)</span><br><span class="line">	heartbeatChan := heartbeatTicker.C</span><br><span class="line">	msgTimeout := client.MsgTimeout</span><br><span class="line"></span><br><span class="line">	flushed := <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在这里关闭startedChan，通知messagePump此goroutine已经完成初始化</span></span><br><span class="line">	<span class="built_in">close</span>(startedChan)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> subChannel == <span class="literal">nil</span> || !client.IsReadyForMessages() &#123;</span><br><span class="line">			<span class="comment">// 客户端还没准备好接收数据</span></span><br><span class="line">			memoryMsgChan = <span class="literal">nil</span></span><br><span class="line">			backendMsgChan = <span class="literal">nil</span></span><br><span class="line">			flusherChan = <span class="literal">nil</span></span><br><span class="line">			<span class="comment">// 强制刷新一次，将client中Inflight的消息发出去。</span></span><br><span class="line">			client.writeLock.Lock()</span><br><span class="line">			err = client.Flush()</span><br><span class="line">			client.writeLock.Unlock()</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">goto</span> exit</span><br><span class="line">			&#125;</span><br><span class="line">			flushed = <span class="literal">true</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> flushed &#123;</span><br><span class="line">			<span class="comment">// 将memoryMsgChan, backendMsgChan设置为</span></span><br><span class="line">			<span class="comment">// 我们订阅的channel所属的memoryMsgChan和backend</span></span><br><span class="line">			memoryMsgChan = subChannel.memoryMsgChan</span><br><span class="line">			backendMsgChan = subChannel.backend.ReadChan()</span><br><span class="line">			flusherChan = <span class="literal">nil</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// buffer中有数据了，设置flusherChan，</span></span><br><span class="line">			<span class="comment">// 保证在OutputBufferTimeout之后可以将消息发送出去</span></span><br><span class="line">			memoryMsgChan = subChannel.memoryMsgChan</span><br><span class="line">			backendMsgChan = subChannel.backend.ReadChan()</span><br><span class="line">			flusherChan = outputBufferTicker.C</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="comment">// OutputBufferTimeout时间到，刷新缓冲区，将消息发送出去</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-flusherChan:</span><br><span class="line">			client.writeLock.Lock()</span><br><span class="line">			err = client.Flush()</span><br><span class="line">			client.writeLock.Unlock()</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">goto</span> exit</span><br><span class="line">			&#125;</span><br><span class="line">			flushed = <span class="literal">true</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-client.ReadyStateChan:</span><br><span class="line">		<span class="keyword">case</span> subChannel = &lt;-subEventChan:</span><br><span class="line">			<span class="comment">// 订阅channel(EXEC(SUB))和更新RDY值时（EXEC(RDY)）时</span></span><br><span class="line">			<span class="comment">// 会往subEventChan和client.ReadyStateChan中发送消息。</span></span><br><span class="line">			<span class="comment">// messagePump如果接收从这两个golang channel中接收到消息，</span></span><br><span class="line">			<span class="comment">// 则不可以再订阅nsq channel</span></span><br><span class="line">			subEventChan = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">case</span> identifyData := &lt;-identifyEventChan:</span><br><span class="line">			<span class="comment">// 同样的，首次连接时执行EXEC(IDENTIRY)</span></span><br><span class="line">			<span class="comment">// 会将客户端的配置通知到identifyEventChan。</span></span><br><span class="line">			<span class="comment">// messagePump接收到后，根据客户端的配置调整心跳频率等。</span></span><br><span class="line">			<span class="comment">// 之后再发送IDENTIFY，messagePump接收不到</span></span><br><span class="line">			identifyEventChan = <span class="literal">nil</span></span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 如下，根据客户端配置，调整不同的参数</span></span><br><span class="line">			outputBufferTicker.Stop()</span><br><span class="line">			<span class="keyword">if</span> identifyData.OutputBufferTimeout &gt; <span class="number">0</span> &#123;</span><br><span class="line">				outputBufferTicker = time.NewTicker(identifyData.OutputBufferTimeout)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			heartbeatTicker.Stop()</span><br><span class="line">			heartbeatChan = <span class="literal">nil</span></span><br><span class="line">			<span class="keyword">if</span> identifyData.HeartbeatInterval &gt; <span class="number">0</span> &#123;</span><br><span class="line">				heartbeatTicker = time.NewTicker(identifyData.HeartbeatInterval)</span><br><span class="line">				heartbeatChan = heartbeatTicker.C</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> identifyData.SampleRate &gt; <span class="number">0</span> &#123;</span><br><span class="line">				sampleRate = identifyData.SampleRate</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			msgTimeout = identifyData.MsgTimeout</span><br><span class="line">		<span class="keyword">case</span> &lt;-heartbeatChan:</span><br><span class="line">			<span class="comment">// 每隔HeartbeatInterval发送一次心跳包</span></span><br><span class="line">			err = p.Send(client, frameTypeResponse, heartbeatBytes)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">goto</span> exit</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">case</span> b := &lt;-backendMsgChan:</span><br><span class="line">			<span class="comment">// 如果backend中有数据，channel会将backend的消息从文件中读出，</span></span><br><span class="line">			<span class="comment">// 发送到golang channel，推送至客户端。</span></span><br><span class="line">			<span class="keyword">if</span> sampleRate &gt; <span class="number">0</span> &amp;&amp; rand.Int31n(<span class="number">100</span>) &gt; sampleRate &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			msg, err := decodeMessage(b)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				p.ctx.nsqd.logf(LOG_ERROR, <span class="string">"failed to decode message - %s"</span>, err)</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 每投递一次消息，则记录一次，超过一定次数就丢弃</span></span><br><span class="line">			msg.Attempts++</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 将消息移到InFlight队列，同时记录该消息在InFlight中的超时时间</span></span><br><span class="line">			subChannel.StartInFlightTimeout(msg, client.ID, msgTimeout)</span><br><span class="line">			<span class="comment">// 增加客户端的InFlightCount和MessageCount</span></span><br><span class="line">			client.SendingMessage()</span><br><span class="line">			<span class="comment">// 将消息写入buffer中</span></span><br><span class="line">			err = p.SendMessage(client, msg)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">goto</span> exit</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 由于buffer中有数据了，将flushed设置为false，可以打开flusherChan</span></span><br><span class="line">			<span class="comment">// 以便触发client.Flush()将消息发出去</span></span><br><span class="line">			flushed = <span class="literal">false</span></span><br><span class="line">		<span class="keyword">case</span> msg := &lt;-memoryMsgChan:</span><br><span class="line">			<span class="comment">// 获取memoryMsgChan中的消息与获取backendMsgChan中的基本一致</span></span><br><span class="line">			<span class="keyword">if</span> sampleRate &gt; <span class="number">0</span> &amp;&amp; rand.Int31n(<span class="number">100</span>) &gt; sampleRate &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			msg.Attempts++</span><br><span class="line"></span><br><span class="line">			subChannel.StartInFlightTimeout(msg, client.ID, msgTimeout)</span><br><span class="line">			client.SendingMessage()</span><br><span class="line">			err = p.SendMessage(client, msg)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">goto</span> exit</span><br><span class="line">			&#125;</span><br><span class="line">			flushed = <span class="literal">false</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-client.ExitChan:</span><br><span class="line">			<span class="comment">// 接收到exit消息，则退出for</span></span><br><span class="line">			<span class="keyword">goto</span> exit</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">exit:</span><br><span class="line">	heartbeatTicker.Stop()</span><br><span class="line">	outputBufferTicker.Stop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>messagePump内部监听flusherChan，client.ReadyStateChan，subEventChan，identifyEventChan，heartbeatChan，backendMsgChan，memoryMsgChan，client.ExitChan这些事件。当监听到subEventChan后，客户端开始订阅某一个channel，之后不能再订阅其他channel。当客户端更新其RDY值到可接收消息状态时，将backendMsgChan和memoryMsgChan设置为该channel的backendMsgChan和memoryMsgChan，开始监听这两个队列事件。当从这两个队列接收到一定量的消息后，停止接收，并且发送至客户端，直到客户端重新更新其RDY值到可接收消息状态，nsqd才会继续推送。所以，每个tcp连接的内部都维护了两个工作协程。通过若干个golang channel在两个协程之间同步信息，如下图所示。</p>
<p><img algn="center" src="/img/nsqd-IOLoop.png"></p>
<p>messgePump在<em>case b := &lt;-backendMsgChan</em>和<em>case msg := &lt;-memoryMsgChan</em>中往客户端发送消息。两个case中做的事情大体上是一样的，主要是：增加消息的被发送次数，移到InFlight队列，消息数据写入到缓冲区准备发送。我们看下移到InFlight队列是如何做的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Channel)</span> <span class="title">StartInFlightTimeout</span><span class="params">(msg *Message, clientID <span class="keyword">int64</span>, timeout time.Duration)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	now := time.Now()</span><br><span class="line">	<span class="comment">// 指定msg.clientID为本次投递的client</span></span><br><span class="line">	msg.clientID = clientID</span><br><span class="line">	<span class="comment">// 投递的时间</span></span><br><span class="line">	msg.deliveryTS = now</span><br><span class="line">	<span class="comment">// 设置消息在InFlight队列的超时时间</span></span><br><span class="line">	msg.pri = now.Add(timeout).UnixNano()</span><br><span class="line">	<span class="comment">// 将消息放入InFlight队列</span></span><br><span class="line">	err := c.pushInFlightMessage(msg)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	c.addToInFlightPQ(msg)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Channel)</span> <span class="title">pushInFlightMessage</span><span class="params">(msg *Message)</span> <span class="title">error</span></span> &#123;    </span><br><span class="line">	c.inFlightMutex.Lock()</span><br><span class="line">	_, ok := c.inFlightMessages[msg.ID]</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		c.inFlightMutex.Unlock()</span><br><span class="line">		<span class="comment">// 消息已经在InFlight队列</span></span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">"ID already in flight"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	c.inFlightMessages[msg.ID] = msg</span><br><span class="line">	c.inFlightMutex.Unlock()</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，理想情况下所有投递出去的消息都被放入InFlight中，等待客户端确认。当nsqd收到客户端的确认后，将消息移出InFlight。如果一直没有收到确认，我们前面提过，会由queueScanWorker保证将InFlight中超时的消息重新投递。</p>
<h2 id="3-常见问题"><a href="#3-常见问题" class="headerlink" title="3. 常见问题"></a>3. 常见问题</h2><p>文章中只介绍了nsqd启动，nsqd接收和发送消息，没有具体到其他细节，比如nsqd如何接收客户端确认，收到确认后做些什么。但是，已经涵盖了nsqd中比较重要的部分。接下来会对一些使用中常见的问题做一下分析。</p>
<h3 id="3-1-ID-not-in-flight"><a href="#3-1-ID-not-in-flight" class="headerlink" title="3.1 ID not in flight"></a>3.1 ID not in flight</h3><p>之前提过，每个channel有两个队列用来接收topic分发的消息，分别是memoryMsgChan和backend。其中memoryMsgChan是一个带缓冲的golang channel，其长度是有限的；backend是一个基于文件的队列。当memoryMsgChan满了之后，消息会被存储入backend中。nsqd首先会从这两个队列中获取消息，给消息设置本次投递的消费端ID，投递的次数，超时时间等信息之后移到InFlight队列中，最后推送给消费端。当接收到消费端确认之后，将消息从InFlight中移除。消费端确认的方式有以下几种：<code>touch</code>,<code>finish</code>,<code>requeue</code>。touch指更新某消息在InFlight队列中的超时时间，nsqd的做法是先将此消息移出InFlight，更新超时时间之后重新放入InFlight。finish指消费端正常接收并处理了消息，告知nsqd可以从InFlight中移除此消息。requeue指消费端接收到此消息，但是可能因为处理失败或者其他什么原因需要再次处理，希望nsqd将此消息从InFlight中重新移到memoryMsgChan或者backend中排队。从InFlight中移除消息的函数如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// popInFlightMessage atomically removes a message from the in-flight dictionary</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Channel)</span> <span class="title">popInFlightMessage</span><span class="params">(clientID <span class="keyword">int64</span>, id MessageID)</span> <span class="params">(*Message, error)</span></span> &#123;</span><br><span class="line">	c.inFlightMutex.Lock()</span><br><span class="line">	msg, ok := c.inFlightMessages[id]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		c.inFlightMutex.Unlock()</span><br><span class="line">		<span class="comment">// 需要移除的消息已经不在InFlight中 </span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"ID not in flight"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> msg.clientID != clientID &#123;</span><br><span class="line">		c.inFlightMutex.Unlock()</span><br><span class="line">		<span class="comment">// 消息在InFlight中，但是当前投递的客户端已经跟上一次不同</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"client does not own message"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">delete</span>(c.inFlightMessages, id)</span><br><span class="line">	c.inFlightMutex.Unlock()</span><br><span class="line">	<span class="keyword">return</span> msg, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当消息已经不在InFlight队列，但是又收到客户端的确认消息时，nsqd会出现ID not in flight报警提示。我们来分析一下在什么场景中可能出现这种情况。假设当前有个消息M被推送给消费端C1，nsqd给M设置推送次数(M.Attempts++)，消费端id(M.clientID=C1.id)，投递时间(M.deliveryTS=now)，超时时间(M.pri=now.Add(timeout),UnixNano())之后将消息移到InFlight。如果因为网络，计算量大等因素，导致C1迟迟没有给nsqd发送确认消息，一直到当前时刻大于M.pri，M被认为超时，由nsqd将消息移出InFlight队列，重新排队。在M重新排队期间，nsqd接收到C1的确认，由于此时M已经不在InFlight中，nsqd给消费端返回ID not in flight。所以我们知道，如果受外因影响严重的应用环境或者本身的计算量就很大，这种情况会被放大叠加，消息一直处于重新排队，重新投递的循环中，最终消息会不断堆积，即使增加消费能力也于事无补。解决方法除了提高程序的效率，应用环境的可靠性外，从nsqd的角度来说，可以通过配置增加每个消息在InFlight队列中的超时时间，或者在程序运行中间对消息进行touch，更新其在InFlight中的超时时间。</p>
<h3 id="3-2-client-does-not-own-message"><a href="#3-2-client-does-not-own-message" class="headerlink" title="3.2 client does not own message"></a>3.2 client does not own message</h3><p>这个问题的本质跟ID not in flight一样。场景是这样：nsqd将M推送给C1之后，一直没有收到C1确认，超时时间到了之后将M移出InFlight重新排队。之后M被重新投递给C2，因此被移到InFlight中。此时C1往nsqd发送确认，这时候M确实在InFlight中，但是投递的客户端已经是C2了，所以nsqd给C1返回client does not own message。所以我们知道，如果M正在排队还没投递，出现的提示是ID not in flight，如果已经重新投递则是client does not own message。解决方法跟之前一样，也是增加消息待在InFlight队列的时间。</p>
<h3 id="3-3-消费端从nsq获取消息的速度快吗"><a href="#3-3-消费端从nsq获取消息的速度快吗" class="headerlink" title="3.3 消费端从nsq获取消息的速度快吗"></a>3.3 消费端从nsq获取消息的速度快吗</h3><p>之前说过，nsq的消息并不是消费端主动获取，而是nsq主动推送。消费端代码需要有自己的一套机制去更新RDY值，告知nsqd最多可以接收多少的消息。以python的客户端代码pynsq为例，nsq.Reader中有一个参数max_in_flight，用于指定nsqd一次推送的消息数量，以便客户端可以一次获取较多消息提高传输效率。如果消费端与nsqd建立了多个连接，所有连接的RDY值之和不能超过max_in_flight。</p>
<p>比如客户端C更新其RDY值为100，并告知nsqd。nsqd负责收集100条消息准备发送至客户端，并且在收集第一条消息的时候就会开启一个定时器。如果在此定时器时间到来之前准备好100条数据，则直接发送出去，如果时间到了还没准备好数据，也会发出去。所以，对于消息生产很快的场景，nsqd收集到固定消息之后就会直接发送，延迟基本可以认为是网络延迟。消息生产较慢的场景，则依赖此定时器的时间，默认值是1s。当然，在客户端代码中增加output_buffer_timeout配置，可以修改此时间。</p>
<h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h2><p><a href="https://nsq.io/overview/design.html" target="_blank" rel="noopener">nsq官方文档</a></p>

        </section>
        <hr/>
        <nav class="pagination" style="width:auto" role="pagination">
            
            <a style="cursor:default" class="newer-posts" href="#">This is the First Post</a>
            
            <a class="share-button" data-original-title title>Share this Post</a>
            
            <a data-pjax class="older-posts" href="/2018/04/07/用redis构建分布式锁/">Next Post →</a>
            
        </nav>
        <br/>
        <br/>
        <section id="comment">
            <div id="comment-box"></div>
        </section>


    </article>
</main>


  
<footer class="site-footer">
    
    <div class="inner">
        <section class="copyright"><a href="/"></a> &copy; pan D.wei's Blog 2016</section>
    </div>
</footer>
</div>
</div><!-- /scroller -->

</div><!-- /pusher -->
</div><!-- /container -->
</div>

<!-- Easter eggs -->

<div class="egg animated">
    <a id="close-button" href="#">X</a>
    <div class="block">
        <div class="loading">
            <span class="ball1"></span>
            <span class="ball2"></span>
        </div>
    </div>
</div>

  
<script src="//cdn.staticfile.org/jquery/1.11.0/jquery.min.js"></script>
<script>
    if (!window.jQuery) {
        var script = document.createElement('script');
        script.src = "/js/jquery.min.js";
        document.body.appendChild(script);
    }
</script>
<script type="text/javascript" src="/js/lean-analystics.js"></script>
<script type="text/javascript" src="/js/lib.js"></script>
<script type="text/javascript" src="/js/main.js"></script>







</body>
</html>
